# Advanced debugging of GLSL shaders

### Systematic Analysis

#### 1. Current State of `debug_step`
*   **WASM Side**: In control_flow.rs, `debug_step` is injected before most statements. It currently passes `(line, func_id, result_ptr)`.
*   **JS Side**: In webgl2_context.js, `debug_step` is a host function that looks up a generated JS stub by line number and executes it.
*   **Stub Generation**: stub.rs generates an array of JS functions. Currently, these functions take no arguments and simply call `this.go()` if the statement is a function call (for trampolining).

#### 2. Variable Tracking in Naga Backend
*   **Globals**: Tracked in `Compiler.global_offsets` as `(offset, base_ptr_idx)`. They reside in linear memory, partitioned by address space (Uniform, Private, etc.).
*   **Locals**: Tracked in `TranslationContext.local_offsets`. They are mapped directly to WASM locals.
*   **Arguments**: Tracked in `TranslationContext.argument_local_offsets`, also mapped to WASM locals.

#### 3. Challenges for Variable Capture
*   **WASM Signatures**: WASM imports must have fixed signatures. We cannot have a `debug_step` that takes a variable number of arguments depending on the line.
*   **Scope Mapping**: The JS stub generator needs to know exactly which variables are in scope at each line to generate the correct function signature.
*   **Data Marshalling**: Complex Naga types (vec3, mat4) need to be flattened or serialized into linear memory so the JS side can read them.

---

### Implementation Plan

#### Phase 1: Metadata & Scope Analysis (Rust)
1.  **Enhance `JsStubGenerator`**:
    *   Modify `analyze_calls` to also map every `naga::Span` to its containing `naga::Function`.
    *   For each function, collect a list of "Debug Symbols":
        *   **Globals**: All `module.global_variables` with their names and types.
        *   **Locals**: All `func.local_variables` with their names and types.
        *   **Arguments**: All `func.arguments` with their names and types.
2.  **Signature Generation**:
    *   Update `JsStubGenerator::generate` to produce JS functions with named parameters.
    *   Example: `(global_pos, global_color, local_temp, arg_uv) => { ... }`.

#### Phase 2: WASM Instruction Injection (Rust)
1.  **Define Debug Buffers**:
    *   Reserve two fixed regions in WASM linear memory:
        *   `DEBUG_GLOBALS_PTR` (e.g., `0x20000`): Stores the current state of all global variables.
        *   `DEBUG_LOCALS_PTR` (e.g., `0x21000`): Stores the current state of locals for the active call stack.
2.  **Global Capture (Entry Point)**:
    *   In backend.rs, at the start of `compile_entry_point`, inject instructions to:
        *   Load every global variable from its respective memory location (using `global_offsets`).
        *   Store them sequentially into `DEBUG_GLOBALS_PTR`.
3.  **Local Capture (Every `debug_step`)**:
    *   In control_flow.rs, before the `Call(debug_step_idx)` instruction:
        *   Iterate through all arguments and local variables of the current function.
        *   Emit `LocalGet` for each.
        *   Emit `F32Store` (or `I32Store`) to write them sequentially into `DEBUG_LOCALS_PTR`.
4.  **Update `debug_step` Call**:
    *   The signature remains `(line, func_id, var_buffer_ptr)`, where `var_buffer_ptr` now points to the start of the captured locals for that specific call.

#### Phase 3: JS Runtime Integration (JavaScript)
1.  **Update `createDebugEnv` in webgl2_context.js**:
    *   Modify the `debug_step` host function to:
        1.  Access the WASM memory buffer.
        2.  Read the global variables from `DEBUG_GLOBALS_PTR`.
        3.  Read the local variables from `DEBUG_LOCALS_PTR`.
        4.  Unpack these values into a flat array of numbers (matching the order generated in Phase 1).
        5.  Execute the stub: `stubFuncs[line - 1].apply(ctx, unpackedValues)`.

#### Phase 4: Refinement & Types
1.  **Type Handling**:
    *   Implement a helper in types.rs to determine the "flattened" size of any Naga type.
    *   Ensure the WASM injection and JS unpacking use the same flattening logic (e.g., a `vec3` becomes 3 consecutive `f32` values).
2.  **Named Arguments**:
    *   Ensure that if a Naga local is named `foo`, the JS stub argument is also named `foo`. If unnamed, use a synthetic name like `local_123`.

### Summary of Changes Required for the main functionality
*   **stub.rs**: Major logic to track scope and generate named arguments in JS.
*   **control_flow.rs**: Logic to inject `LocalGet` and `Store` instructions before every `debug_step`.
*   **backend.rs**: Logic to inject global variable capture at entry points.
*   **webgl2_context.js**: Logic to read and unpack memory in the `debug_step` host function.


### The Testing Plan

The plan is to use a complex shader with nested calls and intercept `debug_step`. It fits perfectly into the bigger plan by acting as the verification step for the data marshalling logic (WASM $\to$ JS).

**Key Considerations for the Test:**
1.  **Shadow Stack Requirement**: Since WASM memory is linear, simply writing locals to a fixed `DEBUG_LOCALS_PTR` would overwrite the caller's locals when entering a nested function. To support "capturing... each call stack," the JS side (the `debug_step` handler) must maintain a **Shadow Stack**.
    *   When `debug_step` is called, it provides the *current* frame's locals.
    *   The JS test harness must push these to a stack to verify the full state (Caller Locals + Callee Locals).
2.  **Data Integrity**: The test must verify that values are preserved across calls (e.g., a local variable in `main` should have the same value before and after calling `helper`).

### Proposed Test Implementation Plan

A new test file should be created in `test/debug_shader_capture.test.js` that implements the testing strategy.

#### 1. The Test Shader
A shader specifically designed to exercise all capture types:
```glsl
#version 300 es
precision highp float;
uniform float u_GlobalVar; // Global to capture
out vec4 fragColor;

float nestedFunc(float param) {
    float local_nested = param * 2.0;
    return local_nested; // Expect: u_GlobalVar, param, local_nested
}

void main() {
    float local_main = 10.0;
    float result = nestedFunc(local_main); // Expect: u_GlobalVar, local_main
    fragColor = vec4(result, 0.0, 0.0, 1.0); // Expect: u_GlobalVar, local_main, result
}
```

#### 2. The Test Logic
The test will:
1.  **Mock the Environment**: Setup a headless WebGL2 context (using the existing webgl2_context.js infrastructure).
2.  **Instrument `debug_step`**:
    *   Instead of the default handler, inject a spy function.
    *   The spy will record: `[LineNumber, FunctionName, CapturedGlobals, CapturedLocals]`.
3.  **Execute**: Run a single draw call.
4.  **Verify**:
    *   **Step 1 (main)**: Assert `local_main` is 10.0.
    *   **Step 2 (nestedFunc)**: Assert `param` is 10.0, `local_nested` is 20.0. Assert `u_GlobalVar` is correct.
    *   **Step 3 (main)**: Assert `result` is 20.0.

### Integration with the Bigger Plan

This test drives the implementation requirements:
*   **Requirement 1**: The WASM backend *must* emit code to dump locals to memory before *every* `debug_step`.
*   **Requirement 2**: The JS stub generator *must* provide the correct variable names and types for the test to verify them by name (e.g., `args.local_main`).
*   **Requirement 3**: The runtime *must* correctly read the `DEBUG_GLOBALS_PTR` and `DEBUG_LOCALS_PTR` offsets.

