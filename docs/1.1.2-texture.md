# Texture plan for WASM-backed WebGL2 façade

## Purpose

Capture the concrete implementation plan, validation rules, data model, tests, and caveats for the texture-related subset of `WasmWebGL2RenderingContext`.

This document records the small, low-risk migration from a minimal CPU-side pixel store toward a WebGL2-like behavior that:
- accepts valid combinations of format/ type/ target/level/size
- rejects invalid combinations using WebGL-like semantics (GL error flag via `getError()` rather than throwing JS exceptions for normal GL errors)
- maintains a clear separation of ABI/fatal errors (throw) vs GL validation errors (set per-context last-error)
- remains WASM-native (no surfman/native GPU backend integration at this stage)

Files referenced in this plan live in the workspace root or under `src/` and `docs/`. When referring to files or symbols we use backticks (for example: `src/webgl2_context.rs`, `src/webgl2_context.js`).

---

## Background / Current state

- Rust context currently stores textures as:
  - `Texture { width, height, data: Vec<u8> }`
  - Exports: `wasm_ctx_create_texture`, `wasm_ctx_delete_texture`, `wasm_ctx_bind_texture`, `wasm_ctx_tex_image_2d`, `wasm_ctx_read_pixels`, `wasm_alloc`, `wasm_free`.
  - `wasm_free` currently no-ops (leaks memory).
- JS façade (`WasmWebGL2RenderingContext`) forwards to wasm exports and throws when an exported call returns non-zero. This conflates ABI-level errors and GL validation errors.
- Servo's `WebGLRenderingContext` (attachment `external/servo/.../webglrenderingcontext.rs`) performs rich validation and tracks a per-context GL error state retrievable by `GetError()`.
- Tests currently exercise a small set of texture flows (1×1 RGBA smoke tests) and all tests pass for the currently implemented subset.

---

## Goals

1. Replace the minimal Rust `Texture` with a richer representation that captures the metadata WebGL needs.
2. Implement validation semantics for texture operations (texImage2D, texSubImage2D, texStorage*, compressed variants, generateMipmap, framebuffer attachment rules, readPixels) so invalid calls set a GL error flag instead of throwing.
3. Implement proper memory management for WASM allocations (`wasm_free`) used for temporary pixel buffers.
4. Update the JS façade to reflect the non-throwing GL error model and provide ergonomic wrappers and tests.
5. Keep the one-wasm-export-per-WebGL-method mapping.

Non-goal: performance optimization or GPU-backed surfman integration at this stage.

---

## High-level tasks (priority ordered)

1. Add texture metadata in Rust (core data model)
2. Implement `wasm_free` & allocation tracking
3. Add GL-style last-error tracking in Rust and expose a `getError` export; update JS `_checkErr()` semantics
4. Implement texImage2D/texSubImage/texStorage validation rules and per-level image bookkeeping
5. Implement readPixels for RGBA/UNSIGNED_BYTE and PACK/UNPACK related flags (UNPACK_ALIGNMENT, PACK_ALIGNMENT, FLIP_Y, PREMULTIPLY_ALPHA)
6. Implement GenerateMipmap semantics and track mipmap state
7. Improve framebuffer attachment validation and compatibility checks used by `readPixels`/`copyTexImage2D`
8. Update the JS façade and add tests for all behaviors
9. Add documentation and a test matrix for future formats/extensions

These map directly to the tracked todos already added in the repository.

---

## Detailed design notes

### 1) Rust Texture data model (suggested structure)

Add or replace the current `Texture` with a structure which, at minimum, contains:

- id: u32 (handle)
- target: TextureTarget (enum) — e.g. TEXTURE_2D, TEXTURE_3D, TEXTURE_CUBE_MAP, TEXTURE_2D_ARRAY
- immutable: bool (set by texStorage* / texStorage2D/3D)
- levels: u32 (number of mipmap levels allocated by texStorage; default 1)
- base_internal_format: InternalFormat (a discriminant of canonical internal formats like RGBA8, RGB8, R8, DEPTH24_STENCIL8, etc.)
- format: ApiFormat (the user-specified format param like RGBA, RGB, ALPHA etc.)
- type_: ApiType (UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5, etc.)
- width, height, depth: u32 (level 0 dimensions)
- min_filter, mag_filter, wrap_s, wrap_t, wrap_r: sampler states stored per-texture
- mipmaps_present: bool (true after generateMipmap or explicit uploads for all levels)
- compressed: bool (true if internal_format indicates compressed format)
- images: Vec<Option<ImageLevel>> where ImageLevel contains width, height, internal_format, format, type_, and an owned Vec<u8> for pixel bytes (or compressed blocks metadata)

Rationale: WebGL validation requires knowing whether a texture is immutable, the internal format, and per-level image extents. Keeping per-level metadata allows `texSubImage2D`/`copyTexSubImage2D` validation and readPixels correctness.

Implementation note: Start with a conservative set of supported internal formats (RGBA8, RGB8, R8, DEPTH24_STENCIL8) and extend later. For now, compressed formats can be flagged as unsupported or partially supported.

### 2) Validation rules (summary)

Implement validation behaviors so that methods set `last_error` on the context and return without throwing for normal GL errors. Example validations to implement first:

- texImage2D / texSubImage2D
  - `target` must be TEXTURE_2D (or other allowed targets depending on call)
  - `level` must be >= 0 and < `levels` (if `levels` is known/immutable)
  - width/height must be >= 1 and not exceed MAX_TEXTURE_SIZE
  - For immutable textures (created by texStorage*), the internal format and level sizes must match the immutable allocation (INVALID_OPERATION otherwise)
  - If `data` is null, treat as uninitialized memory for that level (but still validate size and enums)
  - `format` and `type` combos must be API-supported — if unsupported, set INVALID_ENUM/INVALID_OPERATION per spec
  - Honor `UNPACK_ALIGNMENT` when reading an ArrayBufferView for copy size and stride

- GenerateMipmap
  - If texture is incomplete for sampling with min filter requiring mipmaps (or generateMipmap can't succeed), set INVALID_OPERATION
  - Create/mark mipmap levels present and compute sizes (floor division by 2) for each level

- Framebuffer attachment and readPixels
  - Framebuffer must be complete (implement a small completeness check: color attachment present, same size, supported formats)
  - readPixels should verify framebuffer is complete and that requested format/type are supported. For now, support RGBA/UNSIGNED_BYTE and set IMPLEMENTATION_COLOR_READ_* to those constants (like Servo does)

Detailed rule references: use the WebGL2 spec sections for texImage2D, texSubImage2D, texStorage, generateMipmap, framebuffer completeness, and readPixels. Servo's implementation is a useful working reference (see `external/servo/components/script/dom/webgl/webglrenderingcontext.rs`).

### 3) Error model changes

- Add `last_error: Option<WebGLError>` to the Rust context struct.
- On any GL validation failure, set `last_error` to the appropriate `WebGLError` (InvalidEnum, InvalidValue, InvalidOperation, OutOfMemory, InvalidFramebufferOperation, ContextLost) and return success at the ABI-level (do not throw/return fatal error code).
- Keep ABI-level return values reserved for fatal contract/host errors (bad pointer, OOB, allocation failure). Those should continue to be signalled as non-zero returns so JS can throw.
- Export a `wasm_ctx_get_error(ctx_handle)` or reuse `wasm_last_error_ptr`/`wasm_last_error_len` as a separate channel for GL errors. The JS wrapper should expose a `getError()` method that calls into wasm to read and clear the last GL error.

JS changes:
- Change `_checkErr()` so it only throws for ABI-level failures. For normal WebGL calls, don't throw for GL validation errors — instead rely on `getError()` to report them (matching WebGL semantics).

### 4) Memory management (`wasm_alloc` / `wasm_free`)

- Implement `wasm_free(ptr, len)` in Rust to reclaim allocations created by `wasm_alloc`. Track allocations or use an allocator that supports free (for example, use `wee_alloc` or `dlmalloc` depending on existing project setup).
- Alternative approach: accept typed array pointers from JS directly and avoid Round-Trip allocations in Rust for common flows; but implement `wasm_free` anyway for test harnesses and temporary buffers.

### 5) readPixels & pixel store flags

- Implement support for `UNPACK_ALIGNMENT` and `PACK_ALIGNMENT` and minimally for `UNPACK_FLIP_Y_WEBGL` and `UNPACK_PREMULTIPLY_ALPHA_WEBGL` effects when uploading data. For `readPixels`, honor `PACK_ALIGNMENT` and `FLIP_Y` as reflected by the context state.
- Start with support for `RGBA` + `UNSIGNED_BYTE` only. Others can be added later.

### 6) JS façade updates

- `WasmWebGL2RenderingContext`:
  - Make `getError()` call into wasm to get/clear GL errors instead of throwing on every call.
  - Add `texParameteri`/`getTexParameter` wrappers that forward sampler state (min/mag/wrap) to the Rust texture metadata (so validations have the state they need, e.g., generateMipmap and non-power-of-two rules).
  - Methods like `texImage2D` should accept: null, ArrayBufferView, `WasmWebGLTexture` wrappers or raw handles and should pass pointers/lengths to wasm carefully (use `wasm_alloc` and `wasm_free`), or use a memory view to avoid copying if possible.
  - Preserve existing ergonomic `WasmWebGLTexture` wrapper but add `isDeleted()` and reflect `isImmutable()` or expose query methods to read texture metadata via wasm if needed for debugging/tests.

- `_checkErr()` change: only throw when ABI-level return code indicates fatal problem (bad pointer/out-of-memory). For GL validation failures, do not throw; instead rely on `getError()` in tests.

### 7) Tests (minimal conformance matrix)

Create tests under `test/` covering:

- Basic upload/download
  - `texImage2D` RGBA/UNSIGNED_BYTE 1×1 upload + `readPixels` returns expected color (existing smoke test)
- Enum/value validation
  - Invalid format/type combo -> `getError()` returns `INVALID_ENUM` or `INVALID_VALUE` as specified
- Immutable textures
  - `texStorage2D` create immutable levels -> `texImage2D` with different internal_format or size -> `getError()` returns `INVALID_OPERATION`
- generateMipmap
  - On valid base level: generateMipmap sets mipmaps_present and subsequent sampling-ready behavior
  - On invalid cases: non-power-of-two with wrap != CLAMP_TO_EDGE + min filter requiring mipmaps -> `INVALID_OPERATION`
- readPixels and pack alignment
  - Upload 3-pixel-wide rows with different `UNPACK_ALIGNMENT` values and ensure `readPixels` returns bytes matching row packing expectations
- Framebuffer attachment
  - Attach texture with incompatible internal format -> `getError()` on `framebufferTexture2D` or later `CheckFramebufferStatus` semantics

Tests should be written as node:test files (existing harness) and assert against `gl.getError()` results rather than exceptions for GL validation errors.

---

## Verification & quick run steps

After implementing step 1–3 (data model, wasm_free, error model):

1. Build the project (Cargo + wasm target) and ensure `webgl2.wasm` is produced and placed where `index.js` expects it.
2. Run the node tests focusing on texture tests:

```bash
node --test test/createTexture.test.js test/texImage2D.test.js test/readPixels.test.js --parallel=1
```

3. Confirm tests check `getError()` rather than relying on thrown exceptions.

If tests fail, inspect the wasm exports and verify ABI vs GL error separation.

---

## Edge cases & caveats

- Compressed formats: block-size arithmetic is delicate. Defer supporting compressed textures until uncompressed pipeline is stable, or support decompressed upload paths only.
- Non-power-of-two rules: WebGL2 relaxes many WebGL1 restrictions; be explicit in comments which WebGL version semantics are enforced.
- Memory model: avoid unnecessary copies where possible; but prefer correctness first — implement `wasm_free` to avoid leaks.
- Deleted/bound textures: ensure deleting a bound texture updates binding state (match Servo behavior for WebGL spec compatibility).
- Concurrency: current design assumes single-threaded WASM. If you add threads later, per-context synchronization will be required.

---

## Example minimal Rust `Texture` sketch (conceptual)

> Note: this is a high-level sketch in prose — do not treat as a ready patch. Implementation should reuse the code patterns in `src/webgl2_context.rs` where textures and handles are currently allocated.

Texture fields to add (restate): `target`, `immutable`, `levels`, `base_internal_format`, `format`, `type_`, `width`, `height`, `depth`, sampler states, `mipmaps_present`, `images` vector of per-level metadata + bytes.

---

## Next steps (immediate)

- Extend Rust `Texture` and wire minimal per-level bookkeeping (todo #1)
- Implement `wasm_free` (todo #7)
- Add `last_error` and `getError` ABI export, update JS `_checkErr()` (todo #6)
- Add a test for the 1×1 RGBA upload/readPixels flow using `getError()` (todo #9)

---

## References

- WebGL2 specification: texImage2D, texSubImage2D, texStorage2D/3D, generateMipmap, framebuffer completeness, readPixels
- Servo implementation: `external/servo/components/script/dom/webgl/webglrenderingcontext.rs` (used as a behavior reference)
- Current project files: `src/webgl2_context.rs`, `src/lib.rs`, `src/webgl2_context.js`, `src/webgl2_texture.js` (façade)


