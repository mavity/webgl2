# Result values passed out of shaders

We are reviewing WASM backend generating code for passing the result values out of shaders.

The first part of that review is to understand the way underlying platform represents those result values, and identify individual cases that needs to be handled. The second part is to review how WASM backend handles each of those cases.


## GLSL, WGSL and naga IR treatment of result values

The investigation into naga reveals a consistent but slightly flexible representation of shader results in Naga IR, depending on the source language (GLSL vs. WGSL) and the shader stage.

### **Naga IR Core Representation**

In Naga IR, the mechanism for returning values from a shader is defined by the `EntryPoint` and its underlying `Function`.

*   **`EntryPoint`**: Wraps a `Function` and defines the `ShaderStage` (Vertex, Fragment, Compute).
*   **`Function`**: Contains a `result` field of type `Option<FunctionResult>`.
*   **`FunctionResult`**:
    *   `ty`: `Handle<Type>` (The data type being returned).
    *   `binding`: `Option<Binding>` (Metadata about *where* this result goes).
*   **`Binding`**: Can be:
    *   `BuiltIn`: e.g., `Position`, `FragDepth`, `GlobalInvocationId`.
    *   `Location`: User-defined I/O (e.g., `layout(location = 0)`).
*   **`Statement::Return`**: The function body must end (or exit) with a `Return` statement containing a `value` expression that matches the `FunctionResult` type.

---

### **Map: Shader Kind -> Naga IR Representation**

The representation converges on **returning a value** (except for Compute), but the *structure* of that value differs based on the frontend's parsing strategy.

#### **1. Vertex Shader**

*   **Goal**: Output `Position` (mandatory) and user-defined varyings (optional).
*   **GLSL Frontend (`gl_Position`, `out` variables)**:
    *   **IR Representation**: Always returns a **Struct**.
    *   **Mechanism**: The frontend generates a wrapper `main` function. It loads `gl_Position` and all `out` global variables, packs them into a temporary struct, and returns that struct.
    *   **FunctionResult**:
        *   `ty`: Handle to a `Struct` type.
        *   `binding`: `None` (The bindings are on the struct members).
    *   **Struct Members**:
        *   One member has `Binding::BuiltIn(Position)`.
        *   Other members have `Binding::Location(n)`.
        *   Optional: `Binding::BuiltIn(PointSize)`.

*   **WGSL Frontend (`fn main() -> OutputStruct` or `-> @builtin(position) vec4<f32>`)**:
    *   **IR Representation**: Can be a **Struct** OR a **Single Value**.
    *   **Case A (Struct Return)**: Same as GLSL. `FunctionResult` has `binding: None`, members have bindings.
    *   **Case B (Single Value Return)**: If the shader only returns the position (e.g., `-> @builtin(position) vec4<f32>`), the `FunctionResult` has `ty` as `Vector` and `binding` as `Some(Binding::BuiltIn(Position))`.

#### **2. Fragment Shader**

*   **Goal**: Output Color targets (optional) and Depth (optional).
*   **GLSL Frontend (`out` variables, `gl_FragDepth`)**:
    *   **IR Representation**: Always returns a **Struct**.
    *   **Mechanism**: Similar to vertex. Packs `out` variables and `gl_FragDepth` (if written) into a struct.
    *   **FunctionResult**:
        *   `ty`: Handle to a `Struct` type.
        *   `binding`: `None`.
    *   **Struct Members**:
        *   Members for colors have `Binding::Location(n)`.
        *   Optional member has `Binding::BuiltIn(FragDepth)`.

*   **WGSL Frontend**:
    *   **IR Representation**: Can be a **Struct** OR a **Single Value**.
    *   **Case A (Struct Return)**: `FunctionResult` binding is `None`. Members have `Location(n)` or `BuiltIn(FragDepth)`.
    *   **Case B (Single Value Return)**: e.g., `-> @location(0) vec4<f32>`. `FunctionResult` has `binding: Some(Binding::Location(0))`.

#### **3. Compute Shader**

*   **Goal**: Side effects (write to buffers/images). No direct output.
*   **GLSL & WGSL**:
    *   **IR Representation**: Returns **Nothing**.
    *   **FunctionResult**: `None`.
    *   **Statement::Return**: `value` is `None`.

---

### **Summary Table**

| Shader Stage | Source | Naga IR `FunctionResult` | `Binding` Location | Notes |
| :--- | :--- | :--- | :--- | :--- |
| **Vertex** | **GLSL** | `Struct` | **On Struct Members** | Wrapper function packs globals (`gl_Position`, `out`) into a struct. |
| **Vertex** | **WGSL** | `Struct` | **On Struct Members** | Standard practice for multiple outputs. |
| **Vertex** | **WGSL** | `Vector` | **On FunctionResult** | Only if returning just `@builtin(position)`. |
| **Fragment** | **GLSL** | `Struct` | **On Struct Members** | Wrapper function packs globals (`out`, `gl_FragDepth`) into a struct. |
| **Fragment** | **WGSL** | `Struct` | **On Struct Members** | Standard practice for multiple targets or depth. |
| **Fragment** | **WGSL** | `Vector` | **On FunctionResult** | Only if returning a single color target. |
| **Compute** | **Any** | `None` | N/A | No return value. |

### **Key Implementation Details (from wgpu-fork)**

*   **GLSL Frontend (functions.rs)**:
    The `add_entry_point` function explicitly constructs the return struct. It iterates over `entry_args` with `StorageQualifier::Output`, creates `StructMember`s with the appropriate bindings, emits a `Compose` expression, and generates a `Return` statement with that composed struct.

*   **WGSL Frontend (mod.rs)**:
    The `function` method directly maps the AST result type to the IR `FunctionResult`. The `binding` helper method translates AST attributes (`@location`, `@builtin`) directly to IR `Binding`s. If the return type is a struct, the bindings are expected to be on the struct fields in the type definition itself.

### **Conclusion for Your Project**

The "regrettable flaw" likely stems from assuming a single canonical representation (e.g., "always a struct") or failing to handle the "Single Value with Binding" case that WGSL allows.

To align with Naga/wgpu:
1.  **Expect Flexibility**: Your backend/generator must handle both **Struct-with-member-bindings** and **Value-with-result-binding**.
2.  **GLSL Consistency**: If generating GLSL, you are safe to always pack outputs into a struct, as the GLSL frontend does this internally anyway.
3.  **WGSL Precision**: If generating WGSL or consuming IR derived from it, you must check `function.result.binding`. If it exists, the return value is direct. If it's `None` (and result exists), the return value is a struct, and you must inspect its members for bindings.


## WASM backend implementation


Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend)

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/mod.rs#1-1), lines 1 to 100

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/backend.rs#1-1), lines 1 to 300

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/backend.rs#301-301), lines 301 to 502

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/control_flow.rs#1-1), lines 1 to 300

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/expressions.rs#1-1), lines 1 to 200

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/expressions.rs#700-700), lines 700 to 829

The WASM backend implementation in naga_wasm_backend reveals significant flaws in how it handles shader return values, particularly when compared to the flexible IR representation identified in the previous step.

### **1. Entry Point Signature & Strategy**
The backend enforces a rigid "void return" signature for all entry points, regardless of the shader stage or source language.
*   **Signature**: `(type, attr_ptr, uniform_ptr, varying_ptr, private_ptr, texture_ptr) -> ()`
*   **Strategy**: Instead of returning values on the WASM stack, the backend attempts to intercept `Statement::Return`, calculate the values, and manually store them into memory buffers pointed to by the arguments (specifically `varying_ptr`).

### **2. Handling of Return Values (The Flaws)**
The translation logic in control_flow.rs (`translate_statement`) contains explicit handling for `Statement::Return` that is both incomplete and incorrect for many standard cases.

#### **A. Single Value Returns (WGSL Case B)**
*   **Current Behavior**: **Explicitly Dropped**.
    ```rust
    _ => {
        // Handle single return value (e.g. just position?)
        let num_components = ...;
        for _ in 0..num_components {
            ctx.wasm_func.instruction(&Instruction::Drop);
        }
    }
    ```
*   **Impact**: Any WGSL shader that returns a value directly (e.g., `fn main() -> @builtin(position) vec4<f32>`) will compile but **produce no output**. The calculated position is discarded.

#### **B. Struct Returns (GLSL & WGSL Case A)**
*   **Current Behavior**: Iterates over struct members and attempts to store them based on `Binding`.
*   **Hardcoded Offsets**:
    *   `BuiltIn::Position` $\rightarrow$ `varying_ptr` + offset 0.
    *   `Location(n)` $\rightarrow$ `varying_ptr` + offset `(n + 1) * 16`.
*   **Critical Flaw (Fragment Shaders)**: The logic hardcodes the destination to `varying_ptr` (base pointer 2).
    *   **Vertex Shaders**: This works by accident for `Position` and `Location` outputs, assuming the renderer expects varyings at these exact offsets.
    *   **Fragment Shaders**: This is **incorrect**. Fragment shader outputs (colors) should be written to the frame buffer or a designated output buffer (likely `private_ptr` in this specific memory layout), not the varying buffer. Writing FS outputs to the varying buffer will overwrite vertex data or write to undefined memory, resulting in no visible output.

#### **C. Missing Bindings**
*   **FragDepth**: Completely ignored. If a shader returns a struct with `BuiltIn::FragDepth`, it falls into the `_ => (0, 0)` case and is dropped.
*   **Fragment Outputs**: `Location(0)` in a fragment shader (the color output) is treated as a varying at offset 16, which is semantically wrong.

### **3. Integration with Renderer Logic**
The backend.rs file defines a `MemoryLayout` and global offset logic that partially contradicts the return handling:
*   **Globals**: It attempts to map global variables (like `gl_FragColor`) to `private_ptr` (offset 3).
*   **Returns**: The return statement handler ignores these global mappings and forces struct members into `varying_ptr`.

### **Summary of Flaws**

| Case | Source | Naga IR | WASM Backend Result |
| :--- | :--- | :--- | :--- |
| **Vertex Position** | WGSL (Single) | `Vector` + `Binding` | **FAILURE**: Value dropped. |
| **Vertex Position** | GLSL/WGSL (Struct) | `Struct` | **Success**: Writes to `varying_ptr + 0`. |
| **Vertex Varying** | GLSL/WGSL (Struct) | `Struct` | **Partial Success**: Writes to `varying_ptr + (loc+1)*16`. Rigid layout. |
| **Fragment Color** | WGSL (Single) | `Vector` + `Binding` | **FAILURE**: Value dropped. |
| **Fragment Color** | GLSL/WGSL (Struct) | `Struct` | **FAILURE**: Writes to `varying_ptr` (wrong buffer). |
| **Fragment Depth** | Any | `Struct` | **FAILURE**: Value dropped (unhandled binding). |

### **Possible remediations**
1.  **Handle Single Value Returns**: The `_` match arm in `Statement::Return` must check `ctx.func.result.binding`. If present, it should treat the single value exactly like a struct member with that binding.
2.  **Context-Aware Destinations**: The storage logic must distinguish between **Vertex** and **Fragment** stages.
    *   **Vertex**: `Position` and `Location` $\rightarrow$ `varying_ptr`.
    *   **Fragment**: `Location` (Color) $\rightarrow$ `private_ptr` (or a new `output_ptr`). `FragDepth` $\rightarrow$ `private_ptr` (special offset).
3.  **Dynamic Offsets**: Instead of hardcoding `(n+1)*16`, the backend should respect the memory layout defined in backend.rs or `MemoryLayout` struct to ensure consistency between the host (renderer) and the guest (WASM).


## Practical suggestions

Here are the specific practical steps to remediate the identified flaws in the WASM backend.

### **Step 1: Implement Deterministic Packed Layout**
Instead of using fixed slots based on Location indices (which creates wasteful gaps) or writing outputs to the `private` buffer (which risks collisions with `var<private>` globals), we will implement a **Deterministic Packed Layout**. Both the Generator (WASM backend) and the Runtime (Main WASM) will use the same algorithm to determine where data lives, ensuring zero wasted space and maximum efficiency.

**Algorithm**:
1.  **Collect**: Gather all output fields (from the return Struct or the single return Value).
2.  **Sort**: Sort fields deterministically to ensure stability.
    *   *Primary Key*: Category (`BuiltIn` first, then `Location`).
    *   *Secondary Key*: Index (e.g., `Location(0)` before `Location(1)`).
3.  **Pack**: Iterate through the sorted fields and assign offsets.
    *   `offset = align_up(current_offset, field_alignment)`
    *   `field.offset = offset`
    *   `current_offset = offset + field_size`

**Example Result (Vertex)**:
*   `Position` (vec4): Offset 0
*   `Location(0)` (vec4): Offset 16
*   `PointSize` (f32): Offset 32
*   `Location(3)` (f32): Offset 36
*   **Total Size**: 40 bytes. (Previous plan would have been ~80+ bytes with gaps).

### **Step 2: Introduce Dedicated Output Buffer (Ptr 5)**
We need to separate Fragment outputs from `private` globals to avoid collisions, but now the buffer will be exactly as small as needed.
*   **Vertex Shader**: Writes to `varying_ptr` (Ptr 2).
*   **Fragment Shader**: Writes to a new `output_ptr` (Ptr 5).

**Action**: Update `backend.rs` to generate the new signature `(..., varying_ptr, private_ptr, output_ptr, texture_ptr)` and update the JS glue code to allocate and pass this new `Float32Array`.

### **Step 3: Implement Shared Layout Logic in Backend**
The `naga_wasm_backend` crate should expose a helper (or use it internally) that computes this layout.

*   **In `backend.rs`**:
    *   Create a `LayoutContext` that runs the algorithm above on the `naga::Function`.
    *   Generate the WASM `Store` instructions using these computed offsets.

### **Step 4: Runtime Integration**
The runtime (which invokes the WASM) must use the same logic to read the data.
*   Since the runtime likely has access to the `naga::Module` (used to generate the WASM), it can run the same "Collect & Sort & Pack" algorithm to know that `Location(3)` is at `Offset 36`.

### **Step 5: Refactor `Statement::Return` in control_flow.rs**
Update the control flow handler to be data-driven rather than formula-driven.

**Action**: Rewrite the `Statement::Return` handler to use a unified "Store Result" logic.
1.  **Identify the Data Source**:
    *   If `value` is a Struct, iterate members (in reverse).
    *   If `value` is a Single Value (Vector/Scalar), treat it as a single "member" using `ctx.func.result.binding`.
2.  **Resolve Offset**:
    *   Use the layout computed in Step 3: `offset = layout.get_offset(binding)`.
3.  **Emit Store Instructions**:
    *   Reuse the existing component-wise store logic (pop to scratch, store to memory).

### **Step 6: Handle Single Value Returns (WGSL Case)**
In control_flow.rs, the `_` match arm for `TypeInner` currently drops values.

**Action**:
1.  Check `ctx.func.result.binding`.
2.  If it exists, invoke the logic from Step 5.
3.  If it is `None` (and the type is not a struct), this is likely a logic error in the shader or backend (WGSL requires bindings for entry point outputs), but safe to drop.

### **Step 7: Verify `FragDepth` Handling**
Explicitly add support for `BuiltIn::FragDepth`.

**Action**:
*   Ensure the packing algorithm includes `FragDepth`.
*   In the store loop, ensure `F32Store` is used (Depth is always `f32`).

### **Example Logic Structure (Pseudocode)**
```rust
// Inside Statement::Return handler
let (base_ptr, offset) = match (ctx.stage, binding) {
    (Vertex, BuiltIn::Position) => (2, 0),
    (Fragment, Location(loc)) => (3, loc *// Inside Statement::Return handler
let (base_ptr, offset) = match (ctx.stage, binding) {
    (Vertex, BuiltIn::Position) => (2, 0),
    (Fragment, Location(loc)) => (3, loc * 16),
    // ... handle other cases
};
// Emit store instructions using base_ptr and offset
```