# Result values passed out of shaders

We are reviewing WASM backend generating code for passing the result values out of shaders.

The first part of that review is to understand the way underlying platform represents those result values, and identify individual cases that needs to be handled. The second part is to review how WASM backend handles each of those cases.


## GLSL, WGSL and naga IR treatment of result values

The investigation into naga reveals a consistent but slightly flexible representation of shader results in Naga IR, depending on the source language (GLSL vs. WGSL) and the shader stage.

### **Naga IR Core Representation**

In Naga IR, the mechanism for returning values from a shader is defined by the `EntryPoint` and its underlying `Function`.

*   **`EntryPoint`**: Wraps a `Function` and defines the `ShaderStage` (Vertex, Fragment, Compute).
*   **`Function`**: Contains a `result` field of type `Option<FunctionResult>`.
*   **`FunctionResult`**:
    *   `ty`: `Handle<Type>` (The data type being returned).
    *   `binding`: `Option<Binding>` (Metadata about *where* this result goes).
*   **`Binding`**: Can be:
    *   `BuiltIn`: e.g., `Position`, `FragDepth`, `GlobalInvocationId`.
    *   `Location`: User-defined I/O (e.g., `layout(location = 0)`).
*   **`Statement::Return`**: The function body must end (or exit) with a `Return` statement containing a `value` expression that matches the `FunctionResult` type.

---

### **Map: Shader Kind -> Naga IR Representation**

The representation converges on **returning a value** (except for Compute), but the *structure* of that value differs based on the frontend's parsing strategy.

#### **1. Vertex Shader**

*   **Goal**: Output `Position` (mandatory) and user-defined varyings (optional).
*   **GLSL Frontend (`gl_Position`, `out` variables)**:
    *   **IR Representation**: Always returns a **Struct**.
    *   **Mechanism**: The frontend generates a wrapper `main` function. It loads `gl_Position` and all `out` global variables, packs them into a temporary struct, and returns that struct.
    *   **FunctionResult**:
        *   `ty`: Handle to a `Struct` type.
        *   `binding`: `None` (The bindings are on the struct members).
    *   **Struct Members**:
        *   One member has `Binding::BuiltIn(Position)`.
        *   Other members have `Binding::Location(n)`.
        *   Optional: `Binding::BuiltIn(PointSize)`.

*   **WGSL Frontend (`fn main() -> OutputStruct` or `-> @builtin(position) vec4<f32>`)**:
    *   **IR Representation**: Can be a **Struct** OR a **Single Value**.
    *   **Case A (Struct Return)**: Same as GLSL. `FunctionResult` has `binding: None`, members have bindings.
    *   **Case B (Single Value Return)**: If the shader only returns the position (e.g., `-> @builtin(position) vec4<f32>`), the `FunctionResult` has `ty` as `Vector` and `binding` as `Some(Binding::BuiltIn(Position))`.

#### **2. Fragment Shader**

*   **Goal**: Output Color targets (optional) and Depth (optional).
*   **GLSL Frontend (`out` variables, `gl_FragDepth`)**:
    *   **IR Representation**: Always returns a **Struct**.
    *   **Mechanism**: Similar to vertex. Packs `out` variables and `gl_FragDepth` (if written) into a struct.
    *   **FunctionResult**:
        *   `ty`: Handle to a `Struct` type.
        *   `binding`: `None`.
    *   **Struct Members**:
        *   Members for colors have `Binding::Location(n)`.
        *   Optional member has `Binding::BuiltIn(FragDepth)`.

*   **WGSL Frontend**:
    *   **IR Representation**: Can be a **Struct** OR a **Single Value**.
    *   **Case A (Struct Return)**: `FunctionResult` binding is `None`. Members have `Location(n)` or `BuiltIn(FragDepth)`.
    *   **Case B (Single Value Return)**: e.g., `-> @location(0) vec4<f32>`. `FunctionResult` has `binding: Some(Binding::Location(0))`.

#### **3. Compute Shader**

*   **Goal**: Side effects (write to buffers/images). No direct output.
*   **GLSL & WGSL**:
    *   **IR Representation**: Returns **Nothing**.
    *   **FunctionResult**: `None`.
    *   **Statement::Return**: `value` is `None`.

---

### **Summary Table**

| Shader Stage | Source | Naga IR `FunctionResult` | `Binding` Location | Notes |
| :--- | :--- | :--- | :--- | :--- |
| **Vertex** | **GLSL** | `Struct` | **On Struct Members** | Wrapper function packs globals (`gl_Position`, `out`) into a struct. |
| **Vertex** | **WGSL** | `Struct` | **On Struct Members** | Standard practice for multiple outputs. |
| **Vertex** | **WGSL** | `Vector` | **On FunctionResult** | Only if returning just `@builtin(position)`. |
| **Fragment** | **GLSL** | `Struct` | **On Struct Members** | Wrapper function packs globals (`out`, `gl_FragDepth`) into a struct. |
| **Fragment** | **WGSL** | `Struct` | **On Struct Members** | Standard practice for multiple targets or depth. |
| **Fragment** | **WGSL** | `Vector` | **On FunctionResult** | Only if returning a single color target. |
| **Compute** | **Any** | `None` | N/A | No return value. |

### **Key Implementation Details (from wgpu-fork)**

*   **GLSL Frontend (functions.rs)**:
    The `add_entry_point` function explicitly constructs the return struct. It iterates over `entry_args` with `StorageQualifier::Output`, creates `StructMember`s with the appropriate bindings, emits a `Compose` expression, and generates a `Return` statement with that composed struct.

*   **WGSL Frontend (mod.rs)**:
    The `function` method directly maps the AST result type to the IR `FunctionResult`. The `binding` helper method translates AST attributes (`@location`, `@builtin`) directly to IR `Binding`s. If the return type is a struct, the bindings are expected to be on the struct fields in the type definition itself.

### **Conclusion for Your Project**

The "regrettable flaw" likely stems from assuming a single canonical representation (e.g., "always a struct") or failing to handle the "Single Value with Binding" case that WGSL allows.

To align with Naga/wgpu:
1.  **Expect Flexibility**: Your backend/generator must handle both **Struct-with-member-bindings** and **Value-with-result-binding**.
2.  **GLSL Consistency**: If generating GLSL, you are safe to always pack outputs into a struct, as the GLSL frontend does this internally anyway.
3.  **WGSL Precision**: If generating WGSL or consuming IR derived from it, you must check `function.result.binding`. If it exists, the return value is direct. If it's `None` (and result exists), the return value is a struct, and you must inspect its members for bindings.


## WASM backend implementation


Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend)

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/mod.rs#1-1), lines 1 to 100

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/backend.rs#1-1), lines 1 to 300

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/backend.rs#301-301), lines 301 to 502

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/control_flow.rs#1-1), lines 1 to 300

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/expressions.rs#1-1), lines 1 to 200

Read [](file:///c%3A/Users/mihai/webgl2/src/naga_wasm_backend/expressions.rs#700-700), lines 700 to 829

The WASM backend implementation in naga_wasm_backend reveals significant flaws in how it handles shader return values, particularly when compared to the flexible IR representation identified in the previous step.

### **1. Entry Point Signature & Strategy**
The backend enforces a rigid "void return" signature for all entry points, regardless of the shader stage or source language.
*   **Signature**: `(type, attr_ptr, uniform_ptr, varying_ptr, private_ptr, texture_ptr) -> ()`
*   **Strategy**: Instead of returning values on the WASM stack, the backend attempts to intercept `Statement::Return`, calculate the values, and manually store them into memory buffers pointed to by the arguments (specifically `varying_ptr`).

### **2. Handling of Return Values (The Flaws)**
The translation logic in control_flow.rs (`translate_statement`) contains explicit handling for `Statement::Return` that is both incomplete and incorrect for many standard cases.

#### **A. Single Value Returns (WGSL Case B)**
*   **Current Behavior**: **Explicitly Dropped**.
    ```rust
    _ => {
        // Handle single return value (e.g. just position?)
        let num_components = ...;
        for _ in 0..num_components {
            ctx.wasm_func.instruction(&Instruction::Drop);
        }
    }
    ```
*   **Impact**: Any WGSL shader that returns a value directly (e.g., `fn main() -> @builtin(position) vec4<f32>`) will compile but **produce no output**. The calculated position is discarded.

#### **B. Struct Returns (GLSL & WGSL Case A)**
*   **Current Behavior**: Iterates over struct members and attempts to store them based on `Binding`.
*   **Hardcoded Offsets**:
    *   `BuiltIn::Position` $\rightarrow$ `varying_ptr` + offset 0.
    *   `Location(n)` $\rightarrow$ `varying_ptr` + offset `(n + 1) * 16`.
*   **Critical Flaw (Fragment Shaders)**: The logic hardcodes the destination to `varying_ptr` (base pointer 2).
    *   **Vertex Shaders**: This works by accident for `Position` and `Location` outputs, assuming the renderer expects varyings at these exact offsets.
    *   **Fragment Shaders**: This is **incorrect**. Fragment shader outputs (colors) should be written to the frame buffer or a designated output buffer (likely `private_ptr` in this specific memory layout), not the varying buffer. Writing FS outputs to the varying buffer will overwrite vertex data or write to undefined memory, resulting in no visible output.

#### **C. Missing Bindings**
*   **FragDepth**: Completely ignored. If a shader returns a struct with `BuiltIn::FragDepth`, it falls into the `_ => (0, 0)` case and is dropped.
*   **Fragment Outputs**: `Location(0)` in a fragment shader (the color output) is treated as a varying at offset 16, which is semantically wrong.

### **3. Integration with Renderer Logic**
The backend.rs file defines a `MemoryLayout` and global offset logic that partially contradicts the return handling:
*   **Globals**: It attempts to map global variables (like `gl_FragColor`) to `private_ptr` (offset 3).
*   **Returns**: The return statement handler ignores these global mappings and forces struct members into `varying_ptr`.

### **Summary of Flaws**

| Case | Source | Naga IR | WASM Backend Result |
| :--- | :--- | :--- | :--- |
| **Vertex Position** | WGSL (Single) | `Vector` + `Binding` | **FAILURE**: Value dropped. |
| **Vertex Position** | GLSL/WGSL (Struct) | `Struct` | **Success**: Writes to `varying_ptr + 0`. |
| **Vertex Varying** | GLSL/WGSL (Struct) | `Struct` | **Partial Success**: Writes to `varying_ptr + (loc+1)*16`. Rigid layout. |
| **Fragment Color** | WGSL (Single) | `Vector` + `Binding` | **FAILURE**: Value dropped. |
| **Fragment Color** | GLSL/WGSL (Struct) | `Struct` | **FAILURE**: Writes to `varying_ptr` (wrong buffer). |
| **Fragment Depth** | Any | `Struct` | **FAILURE**: Value dropped (unhandled binding). |

### **Possible remediations**
1.  **Handle Single Value Returns**: The `_` match arm in `Statement::Return` must check `ctx.func.result.binding`. If present, it should treat the single value exactly like a struct member with that binding.
2.  **Context-Aware Destinations**: The storage logic must distinguish between **Vertex** and **Fragment** stages.
    *   **Vertex**: `Position` and `Location` $\rightarrow$ `varying_ptr`.
    *   **Fragment**: `Location` (Color) $\rightarrow$ `private_ptr` (or a new `output_ptr`). `FragDepth` $\rightarrow$ `private_ptr` (special offset).
3.  **Dynamic Offsets**: Instead of hardcoding `(n+1)*16`, the backend should respect the memory layout defined in backend.rs or `MemoryLayout` struct to ensure consistency between the host (renderer) and the guest (WASM).


## Practical suggestions

To address the identified flaws without introducing widespread regression or "Big Bang" churn, we will adopt an **Abstraction First** approach. This involves introducing a layout abstraction layer first (refactoring), then using it to fix bugs (extensions), and finally optimizing it (packing).

### The "Abstraction First" Approach

#### **Step 1: Extract Layout Logic (Refactoring)**

Move the current hardcoded offset math out of `control_flow.rs`, `backend.rs`, and `expressions.rs` into a centralized layout abstraction. This step is further broken down to ensure safety and stability.

**Partial Implementation Already Exists**

The layout abstraction (`src/naga_wasm_backend/output_layout.rs`) **already exists** and is **correctly used** in `control_flow.rs`. However, `backend.rs` and `expressions.rs` still contain **hardcoded duplicate formulas**.

**Step 1.1: Extend Layout Abstraction Layer**

*   **Status**: Modify existing `src/naga_wasm_backend/output_layout.rs`
*   **Actions**:
    1. **Add input offset calculation** (currently missing):
       ```rust
       pub fn compute_input_offset(location: u32, stage: ShaderStage) -> (u32, u32)
       ```
       - Vertex: `(location * 64, ATTR_PTR_GLOBAL)` for attributes
       - Fragment: `((location + 1) * 16, VARYING_PTR_GLOBAL)` for varyings
    
    2. **Add uniform offset calculation**:
       ```rust
       pub fn compute_uniform_offset(location: u32) -> (u32, u32)
       ```
       - Returns: `(location * 64, UNIFORM_PTR_GLOBAL)`
    
    3. **Add comprehensive tests** for new functions (follow existing test pattern at lines 151-260)
*   **Verification**: Unit tests pass. No behavior changes yet (new functions unused).

**Step 1.1+: Return signatures**

**Goal:** Centralize offset logic in output_layout.rs so other code uses a single API. Verify correctness only with JS integration tests (no Rust tests, no alternative options).

---

### Code changes to make (exact files & symbols) ✅

- **File:** output_layout.rs  
  - **Add / expose** two helpers (documented):
    - `pub fn compute_input_offset(location: u32, stage: ShaderStage) -> (u32, u32)` — returns (offset, base_ptr) for vertex *attributes* and fragment *varyings* (e.g., attr: offset = location * 64, base_ptr = ATTR_PTR_GLOBAL; varying: offset = (location + 1) * 16, base_ptr = VARYING_PTR_GLOBAL).
    - `pub fn compute_uniform_offset(location: u32) -> (u32, u32)` — returns (offset, UNIFORM_PTR_GLOBAL) using 64-byte slots.
  - **Add** concise doc comments describing pointer indices: `0=attr`, `1=uniform`, `2=varying`, `3=private`.

- **File:** backend.rs  
  - **Replace** hardcoded formulas (e.g., `loc * 64`, `(loc + 1) * 16`) where global variable offsets are computed with calls to `output_layout::compute_input_offset` and `compute_uniform_offset`. Preserve any name-based fragment heuristics.

- **File:** expressions.rs  
  - **Replace** attribute/varying binding math and binding-based offset lookups with `output_layout::compute_input_offset(location, stage)`.

Notes: Keep changes narrowly scoped to replacing formulae with helper calls and adding documentation. This is a refactor only; do not alter runtime semantics in this step.

### Existing tests (JS)

The existing tests should remain in the same state, or better than before refactoring. Please run the full test suite before starting the work to note down how many tests fail/succeed, then ensure all successful tests should still pass.

### JS verification tests to add

- **`test/output_layout_offsets.test.js`**  
  - Purpose: Verify `compute_input_offset` behavior via observable memory layout.  
  - Test actions:
    - Compile/run a tiny shader that reads/writes a vertex attribute at location L and writes it to a buffer accessible to the host, then read the buffer and assert the value is at offset `location * 64` in `attr_ptr` area.
    - Do the same for a fragment varying at location L and assert it appears at offset `(location + 1) * 16` in `varying_ptr` area.

- **`test/output_layout_uniforms.test.js`**  
  - Purpose: Verify uniform layout mapping.  
  - Test actions:
    - Compile/run a shader that reads a uniform at location L and stores it to a host-visible memory region; assert it appears at offset `location * 64` from `uniform_ptr`.

- **`test/refactor_safety_fragment_color.test.js`**  
  - Purpose: Confirm no behavioral change after refactor.  
  - Test actions:
    - Render a simple fragment shader producing a known color and assert the first pixel equals the expected color (verify via existing framebuffer read helpers).

Test constraints: All new tests must pass before moving on. These are *observational* tests that exercise the refactor via normal runtime flows (build + render + readback).

**NOTE:** NO Rust tests are allowed as part of this task. Only JS tests are accepted.

### Verification procedure & acceptance criteria ✔️

- Run build and tests: `npm run build` then `npm test`.  
- Acceptance: All existing JS tests plus the three new tests pass; no behavior changes are observed in the rendered outputs.



**Step 1.2: Refactor Global Variable Layout (backend.rs)**

*   **Target**: The `compile()` method's global variable processing loop (around lines 165-210)
*   **Context**: This code iterates through `self.module.global_variables` during compilation and assigns memory offsets based on address space and bindings
*   **Critical Issues Found**:
    - **Line ~171:** `loc * 64` (uniform variables) ❌
    - **Line ~201:** `loc * 64` (vertex shader attribute inputs) ❌  
    - **Line ~204:** `(loc + 1) * 16` (vertex shader varying outputs) ❌
*   **Actions**:
    1. **Locate the global variable iteration loop** in the `compile()` method starting around line 168 with `naga::AddressSpace::Uniform`
    
    2. **Replace uniform offset calculation** (around line 171):
       ```rust
       // Before:
       let offset = loc * 64;
       // After:
       let (offset, _) = output_layout::compute_uniform_offset(loc);
       ```
    
    3. **Replace attribute offset calculation** (around line 201):
       ```rust
       // Before:
       let offset = loc * 64;
       // After:
       let (offset, _) = output_layout::compute_input_offset(loc, ShaderStage::Vertex);
       ```
    
    4. **Replace varying offset calculation** (around line 204):
       ```rust
       // Before:
       let offset = (loc + 1) * 16;
       (offset, 2)
       // After:
       output_layout::compute_output_destination(
           &naga::Binding::Location { 
               location: loc, 
               second_blend_source: false,
               interpolation: None, 
               sampling: None 
           },
           self.stage
       )
       ```
       **Note**: This correctly identifies varying outputs as outputs (not inputs), maintaining semantic clarity.
    
    5. **Preserve fragment output detection logic** (around lines 182-198):
       - The name-based heuristic (checking for "color", "gl_FragColor", etc.) is **intentional special-case handling**
       - This logic determines whether to use private_ptr vs varying_ptr for fragment shader globals
       - Do NOT modify this section - it's separate from layout calculation
*   **Verification**: Run `npm test`. All existing tests must pass with **identical behavior**. No new failures.

**Step 1.3: Refactor Input Argument Layout (expressions.rs)**

*   **Target**: Lines 352-410 in `translate_load_function_argument` function
*   **Critical Issues Found**:
    - **Line 369:** `location * 64` (VS attributes) ❌
    - **Line 376:** `(location + 1) * 16` (FS varyings) ❌
    - **Line 387:** `location * 64` (VS attributes via binding) ❌
    - **Line 390:** `(location + 1) * 16` (FS varyings via binding) ❌
*   **Actions**:
    1. **Replace lines 368-378** (named argument lookup):
       ```rust
       // Before:
       if ctx.stage == naga::ShaderStage::Vertex {
           if let Some(&location) = ctx.attribute_locations.get(name) {
               offset = location * 64;
               found_location = true;
           }
       } else if ctx.stage == naga::ShaderStage::Fragment {
           if let Some(&location) = ctx.varying_locations.get(name) {
               offset = (location + 1) * 16;
               found_location = true;
           }
       }
       
       // After:
       if let Some(&location) = match ctx.stage {
           naga::ShaderStage::Vertex => ctx.attribute_locations.get(name),
           naga::ShaderStage::Fragment => ctx.varying_locations.get(name),
           _ => None,
       } {
           (offset, base_ptr) = output_layout::compute_input_offset(location, ctx.stage);
           found_location = true;
       }
       ```
    
    2. **Replace lines 383-391** (binding-based offset):
       ```rust
       // Before:
       if let Some(naga::Binding::Location { location, .. }) = arg.binding {
           if ctx.stage == naga::ShaderStage::Vertex {
               offset = location * 64;
           } else {
               offset = (location + 1) * 16;
           }
       }
       
       // After:
       if let Some(naga::Binding::Location { location, .. }) = arg.binding {
           (offset, base_ptr) = output_layout::compute_input_offset(location, ctx.stage);
       }
       ```
*   **Verification**: Run `npm test`. All tests must pass unchanged. Vertex shader attribute loading unchanged. Fragment shader varying reads unchanged.

**Step 1.4: Cleanup and Documentation**

*   **Actions**:
    1. **Verify no dead code** introduced
    2. **Add documentation** to `output_layout.rs` explaining:
       - Memory layout strategy (why 64-byte uniforms, why 16-byte varyings, why `(loc+1)`)
       - Pointer index meanings (0=attr, 1=uniform, 2=varying, 3=private)
    3. **Run full test suite** with coverage check:
       ```bash
       npm run build
       npm test
       ```
    4. **Verify no regression** by comparing test output before/after refactoring
*   **Success Criteria**:
    - Zero test failures
    - Zero behavior changes
    - All hardcoded formulas removed from `backend.rs` and `expressions.rs`
    - Single source of truth: `output_layout.rs`

**Dependency Graph (Updated)**

```
output_layout.rs (SINGLE SOURCE OF TRUTH)
├── compute_output_destination(binding, stage)  [EXISTING ✅]
├── compute_input_offset(location, stage)        [NEW in 1.1]
└── compute_uniform_offset(location)             [NEW in 1.1]
    │
    ├─→ control_flow.rs          [ALREADY CORRECT ✅]
    ├─→ backend.rs               [FIX in 1.2]
    └─→ expressions.rs           [FIX in 1.3]
```

**Risk Assessment**

| **Risk** | **Probability** | **Impact** | **Mitigation** |
|----------|----------------|------------|----------------|
| Tests break during 1.2 | LOW | HIGH | Each formula replacement is mechanical 1:1 mapping |
| Missing ShaderStage context | NONE | HIGH | Research confirms ctx.stage available everywhere |
| Wrong pointer indices | LOW | HIGH | Research confirms indices are constants (0,1,2,3) |
| Fragment heuristic breaks | MEDIUM | MEDIUM | Keep existing name-based detection (lines 182-198) unchanged |

**Execution Order**

1. **Step 1.1** → Create new functions, add tests → **~30 min**
2. **Step 1.2** → Refactor `backend.rs` → **~45 min**
3. Run `npm test` → Verify → **~5 min**
4. **Step 1.3** → Refactor `expressions.rs` → **~45 min**
5. Run `npm test` → Verify → **~5 min**
6. **Step 1.4** → Documentation, final validation → **~30 min**

**Total Estimated Time:** 3 hours

**Confidence Level:** HIGH (mechanical refactoring with existing abstraction)

#### **Step 2: Extend for Single Values (Bug Fix)**
Update the `LayoutStrategy` usage in `control_flow.rs` to handle single-value returns (WGSL Case B).

**Goal**: Fix the bug where `fn main() -> @builtin(position) vec4<f32>` drops the return value.

**Current State Analysis**

The code in `control_flow.rs` (lines 289-355) already **partially handles** single-value returns with bindings (lines 329-345). The bug is in the `else` branch (lines 347-354) that drops values when `result.binding` is `None` or when struct members lack bindings.

**Incremental Implementation Plan**

This step is broken down into 6 micro-steps, each leaving the code in a stable, testable state:

---

**Step 2.1: Add Test Case (Red Phase)**
*   **Goal**: Create a failing test that exposes the bug  
*   **Duration**: ~15 min  
*   **Risk**: None (only adds test)
*   **Actions**:
    1. Create `test/singleValueReturn.test.js`:
       ```javascript
       // WGSL Case B: fn main() -> @builtin(position) vec4<f32>
       // Currently fails - position is dropped
       ```
    2. Write minimal WGSL vertex shader with single-value return
    3. Run `npm test` - verify new test fails or produces wrong output
    4. **Commit point**: Test added (expected to fail)
*   **Verification**: New test runs, all other tests still pass, code unchanged

---

**Step 2.2: Extract Storage Logic (Refactor)**
*   **Goal**: Create reusable helper for single-value storage  
*   **Duration**: ~20 min  
*   **Risk**: Low (pure extraction)
*   **Actions**:
    1. In `control_flow.rs`, extract a new helper function:
       ```rust
       fn store_single_value_to_output(
           ty: &naga::Type,
           binding: &naga::Binding,
           ctx: &mut TranslationContext,
       ) {
           // Copy logic from lines 329-345
           let num_components = super::types::component_count(&ty.inner, &ctx.module.types);
           let is_int = super::expressions::is_integer_type(&ty.inner);
           let (offset, base_ptr) = get_output_destination(binding, ctx);
           store_components_to_memory(offset, base_ptr, num_components, is_int, ctx);
       }
       ```
    2. Replace lines 329-345 with call to new function
    3. Run `npm test` - all existing tests pass (behavior identical)
    4. **Commit point**: Refactor complete, no behavior change
*   **Verification**: Zero test failures, binary output identical to before

---

**Step 2.3: Handle Single BuiltIn::Position (Green Phase 1)**
*   **Goal**: Fix the specific case of `-> @builtin(position) vec4<f32>`  
*   **Duration**: ~15 min  
*   **Risk**: Low (narrow scope)
*   **Actions**:
    1. Modify the `_` branch `else` block (lines 347-354):
       ```rust
       } else {
           // Check if this is a BuiltIn (like Position) without struct wrapping
           if let naga::TypeInner::Vector { .. } | naga::TypeInner::Scalar { .. } = &ty.inner {
               // Check parent FunctionResult for binding
               if let Some(binding) = &result.binding {
                   if matches!(binding, naga::Binding::BuiltIn(naga::BuiltIn::Position)) {
                       store_single_value_to_output(ty, binding, ctx);
                       continue; // or return Ok(()) depending on control flow
                   }
               }
           }
           
           // Fall through to existing drop logic
           let num_components = super::types::component_count(&ty.inner, &ctx.module.types);
           for _ in 0..num_components {
               ctx.wasm_func.instruction(&Instruction::Drop);
           }
       }
       ```
    2. Run `npm test`
    3. Verify the new test from 2.1 now passes for Position case
    4. **Commit point**: Position single-value returns work
*   **Verification**: New test passes for `@builtin(position)` case, all existing tests still pass

---

**Step 2.4: Handle Single Location Binding (Green Phase 2)**
*   **Goal**: Extend to handle `-> @location(0) vec4<f32>` (fragment colors)  
*   **Duration**: ~10 min  
*   **Risk**: Low (similar pattern)
*   **Actions**:
    1. Expand the condition from 2.3:
       ```rust
       if let Some(binding) = &result.binding {
           match binding {
               naga::Binding::BuiltIn(naga::BuiltIn::Position) |
               naga::Binding::Location { .. } => {
                   store_single_value_to_output(ty, binding, ctx);
                   continue;
               }
               _ => {
                   // Fall through to drop for unsupported bindings
               }
           }
       }
       ```
    2. Add test case for single location return
    3. Run `npm test`
    4. **Commit point**: Location single-value returns work
*   **Verification**: Both Position and Location single-value returns work, no test regressions

---

**Step 2.5: Handle All Binding Types (Complete)**
*   **Goal**: Support FragDepth and any other binding types  
*   **Duration**: ~15 min  
*   **Risk**: Low (comprehensive coverage)
*   **Actions**:
    1. Simplify to handle all bindings:
       ```rust
       } else {
           // Single value return - check FunctionResult binding
           if let Some(binding) = &result.binding {
               store_single_value_to_output(ty, binding, ctx);
           } else {
               // No binding on return value - drop it
               let num_components = super::types::component_count(&ty.inner, &ctx.module.types);
               for _ in 0..num_components {
                   ctx.wasm_func.instruction(&Instruction::Drop);
               }
           }
       }
       ```
    2. Add test for FragDepth single-value return (if not already covered)
    3. Run `npm test` + `npm run build`
    4. **Commit point**: Step 2 complete
*   **Verification**: All single-value return types work, struct returns still work, full test suite passes

---

**Step 2.6: Documentation and Cleanup**
*   **Goal**: Document the fix and edge cases  
*   **Duration**: ~10 min  
*   **Risk**: None
*   **Actions**:
    1. Add comment in `control_flow.rs` explaining the two return patterns:
       ```rust
       // Naga IR supports two return patterns:
       // 1. Struct with bindings on members (GLSL always, WGSL optional)
       // 2. Single value with binding on FunctionResult (WGSL only)
       ```
    2. Update this document to mark Step 2 complete
    3. Run final validation
    4. **Commit point**: Step 2 documentation complete
*   **Verification**: Code is documented, plan document updated

---

**Execution Order & Timeline**

```
2.1 (Test) → 2.2 (Refactor) → 2.3 (Position) → 2.4 (Location) → 2.5 (Complete) → 2.6 (Docs)
   ↓            ↓                 ↓                 ↓                 ↓               ↓
 FAIL      ALL PASS         NEW PASS         MORE PASS        ALL PASS         COMPLETE
```

**Total Estimated Time**: ~1.5 hours  
**Commit Points**: 6  
**Test Stability**: Maintained at each step except 2.1 (intentional red)

**Risk Assessment**

| Step | Risk | Mitigation |
|------|------|------------|
| 2.1 | None | Only adds test |
| 2.2 | Low | Pure extraction, no logic change |
| 2.3 | Low | Narrow scope (Position only) |
| 2.4 | Low | Extends existing pattern |
| 2.5 | Medium | Could affect fragment shaders |
| 2.6 | None | Documentation only |

**Important Note**: Step 2.5 will store single-value fragment returns, but they'll still go to the wrong memory location (`varying_ptr` instead of `private_ptr`). **Step 3 is required** to fix the destination logic for fragment shader outputs.

#### **Step 3: Fix Fragment Targets (Bug Fix)**
Update `LayoutStrategy` to support Fragment Shader outputs correctly.
*   **Goal**: Stop writing Fragment colors to the `varying_ptr`.
*   **Implementation**:
    *   Modify `LayoutStrategy` to accept `ShaderStage`.
    *   For `ShaderStage::Fragment`:
        *   Map `Location(0)` (Color) to `private_ptr` (or a dedicated output pointer if we choose to add one) at offset 0.
        *   Map `BuiltIn::FragDepth` to `private_ptr` at a specific offset (e.g., after the color).
*   **Verification**: Fragment shader tests (currently likely failing or stubbed) should begin to pass. Vertex tests remain unaffected.

#### **Step 4: Implement Packed Layout (Optimization - Deferred)**
Once the abstraction is robust and bugs are fixed, implement a `PackedLayoutStrategy`.
*   **Goal**: Eliminate wasted space in memory buffers.
*   **Implementation**:
    *   Create a new implementation of `LayoutStrategy` that calculates dense offsets (packing).
    *   Switch to this strategy via configuration or flag.
    *   Update the JS runtime to understand the packed layout (potentially by exporting the layout map from the WASM backend).
```