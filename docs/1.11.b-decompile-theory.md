# WASM>Rust Decompiler

This is a plan to implement a new module to decompile WASM bytecode back into GLSL-like C code, mirroring the existing `getShaderWat` functionality but using a custom "WASM-to-GLSL" decompiler instead of `wasmprinter`.

## Phase 1: Foundation & AST Design

Before writing the decompiler, you need a way to represent the logic that isn't just a flat list of bytes.

1. **Define the Intermediate Representation (IR):** Create a recursive `enum` for expressions. This is your "GLSL-flavored AST."
```rust
pub enum Expr {
    I32Const(i32),
    F32Const(f32),
    LocalGet(u32),
    BinaryOp { 
        op: BinOp, 
        left: Box<Expr>, 
        right: Box<Expr> 
    },
    VectorOp {
        op: VecOp,
        args: Vec<Expr>
    },
    MemoryRead {
        offset: u32,
        ty: WasmType
    }
}

```


2. **Integrate `wasmparser`:**
Set up a basic loop that reads a `.wasm` file and identifies function bodies.
3. **Setup the Symbolic Stack:**
Create a `Vec<Expr>` to act as your "Decompile Stack."

---

## Phase 2: The "Lifter" (Core Logic)

This is where you turn stack operations into your `Expr` trees.

1. **Instruction Mapping:**
Write a matcher for standard WASM instructions.
* **On `I32Const(n)`:** Push `Expr::I32Const(n)` to your stack.
* **On `F32Add`:** Pop `right`, pop `left`, push `Expr::BinaryOp { op: Add, left, right }`.


2. **Lifting SIMD to GLSL Vectors:**
Map WASM `v128` operations directly to GLSL types.
* `f32x4.add`  `Expr::VectorOp { op: Add, args: [...] }` which will eventually print as `vec4 + vec4`.


3. **Control Flow Recovery (Simplified):**
For a 0.1.0 version, handle basic `Block`, `Loop`, and `If` using a "structured stack" approach. Don't worry about complex `br_table` (switch statements) yet.

---

## Phase 3: The "Simplifier" (using `egg`)

A raw decompile is unreadable (e.g., `x + 0` or `((a + b) + c)`). `egg` will "rewrite" these into clean code.

1. **Define Rewrite Rules:** Create a rule-set for algebraic simplifications:
```rust
let rules: &[Rewrite<Expr, ()>] = &[
    rewrite!("add-zero"; "(+ ?a 0)" => "?a"),
    rewrite!("commute-add"; "(+ ?a ?b)" => "(+ ?b ?a)"),
    rewrite!("mul-by-two"; "(* ?a 2)" => "(<< ?a 1)"), // Or vice versa for GLSL
];

```


2. **Run Equality Saturation:**
Pass your recovered `Expr` trees through `egg` to find the "simplest" version based on cost (e.g., shorter string length is cheaper).

---

## Phase 4: The GLSL Emitter

The final step is turning your simplified `Expr` tree into a string.

1. **Type Mapping:**
Map WASM types to GLSL keywords:
* `i32`  `int`
* `f32`  `float`
* `v128` (f32x4)  `vec4`


2. **Function Synthesis:**
Wrap the recovered expressions in a standard GLSL function signature.
```glsl
// Recovered output example
vec4 process_vertex(int id) {
    float x = input_buffer[id * 4];
    return vec4(x, 1.0, 0.0, 1.0);
}

```



---

## Phase 5: WASM Portability (The "Meta" Step)

Since you want the tool itself to run in a browser:

1. **`wasm-pack` Setup:**
Ensure your library is marked `cdylib` and use `wasm-bindgen` to expose a `decompile(wasm_bytes)` function.
2. **Pure Rust Dependencies:**
Avoid crates that link to C++ binaries. Use **`egg`** (pure Rust) and **`wasmparser`** (pure Rust).
> **Note:** Do NOT use Z3 if you want easy browser support. Use `egg` for simplification instead.









# Specific Phases in detail

## Phase 1: Foundation & AST Design


**Phase 1** is the "Skeleton" of your decompiler. Its goal is to take a raw `.wasm` file and organize its contents into a structure that you can actually work with.

In this phase, you are not de-stacking logic yet; you are building the **Iterative Parser** and the **Custom AST Container**.

---

### 1. Functional Blocks

To keep the project clean, you should divide Phase 1 into three distinct modules:

* **`parser.rs`**: Handles the event-driven stream from `wasmparser`. It extracts high-level metadata like function names, types, and the raw bytes of each function body.
* **`ast.rs`**: Defines your "GLSL-flavored" tree structure. This is where you translate flat WASM types into high-level concepts (e.g., `i32`  `Int`).
* **`module.rs`**: A container that holds the results of the parse. It acts as the "Database" for your decompiler, storing a map of `FunctionIndex -> FunctionAST`.

---

### 2. The Custom AST (The "Heart" of Phase 1)

As discussed, `wasmparser` only gives you a flat stream. You must define a recursive enum in `ast.rs` to hold the "lifted" results.

```rust
// src/ast.rs

#[derive(Debug, Clone)]
pub enum ScalarType {
    Int,   // i32
    Long,  // i64
    Float, // f32
    Double // f64
}

#[derive(Debug, Clone)]
pub enum Expr {
    // Basic Values
    ConstI32(i32),
    ConstF32(f32),
    LocalGet(u32),
    
    // Math (Recursive!)
    BinaryOp {
        op: String, // e.g., "+"
        left: Box<Expr>,
        right: Box<Expr>,
    },
    
    // GLSL-specific targets
    VectorAdd(Box<Expr>, Box<Expr>), // Will map to `vec4 + vec4`
}

```

---

### 3. Essential Imports & Dependencies

Add these to your `Cargo.toml`. We use `wasmparser` for the heavy lifting and `anyhow` for easier error handling.

```toml
[dependencies]
# The industry standard for WASM parsing
wasmparser = "0.244.0" 
# Error handling made easy
anyhow = "1.0"
# Only if you are building the browser-based tool
wasm-bindgen = "0.2" 

```

---

### 4. Implementation Detail: The Parsing Loop

In `parser.rs`, you will implement a loop that iterates through the WASM "Payloads."

```rust
use wasmparser::{Parser, Payload, Chunk};

pub fn process_wasm(data: &[u8]) -> anyhow::Result<()> {
    let mut parser = Parser::new(0);
    let mut wasm_remainder = data;

    loop {
        let (payload, consumed) = match parser.parse(wasm_remainder, true)? {
            Chunk::Parsed { consumed, payload } => (payload, consumed),
            Chunk::NeedMoreData(_) => break,
        };

        match payload {
            Payload::CodeSectionEntry(body) => {
                // This is a single function body! 
                // We will send this to the "Lifter" in Phase 2.
                let reader = body.get_operators_reader()?;
                println!("Found function with {} bytes of code", body.as_bytes().len());
            }
            Payload::End(_) => break,
            _ => { /* Ignore other sections for now */ }
        }
        wasm_remainder = &wasm_remainder[consumed..];
    }
    Ok(())
}

```

### 5. Why this structure?

By separating the **Parser** (wasmparser) from the **AST** (your custom enum), you ensure that:

1. You can easily swap the emitter (e.g., go from GLSL to Metal or HLSL) without touching the parser.
2. You can implement the `egg` optimizer in Phase 3 by just passing it your `Expr` enum.



## Phase 2: The Lifter (Decompilation Logic)

Phase 2 is the "Translator" that converts the stack-based instructions into your structured AST. To make this pragmatic, we will break it down into three specific sub-systems: **The Stack**, **The Scope**, and **The Consumer**.

### 1. The Symbolic Stack

WASM is a stack machine; your decompiler needs a "fake" stack to track what values are currently pending.

**Steps:**

1. Initialize a `Vec<Expr>` in your `Lifter` struct.
2. When a "pushing" instruction (like `i32.const`) appears, wrap it in your `Expr` enum and push it.
3. When a "consuming" instruction (like `i32.add`) appears, `pop()` the operands.

```rust
// In lifter.rs
pub fn push(&mut self, e: Expr) { self.stack.push(e); }
pub fn pop(&mut self) -> Expr { 
    self.stack.pop().expect("Stack underflow!") 
}

```

### 2. The Control Flow Stack (Scope Tracking)

WASM uses `block`, `loop`, and `if` to define nested regions. You must track these using a separate stack of "Control Frames" to know where `br` (breaks) should point.

**Steps:**

1. Define a `ControlFrame` struct that stores the starting stack height.
2. On `Operator::Block`, push a new frame.
3. On `Operator::End`, pop the frame and move any "leaked" values to the parent's block.

```rust
struct ControlFrame {
    stack_height: usize,
    frame_type: FrameType, // Block, Loop, or If
}
let mut control_stack: Vec<ControlFrame> = vec![];

```

### 3. The Instruction Consumer

This is a `match` statement that processes every instruction from `wasmparser`. We separate them into "Pure Expressions" and "Side-Effect Statements."

**Step 1: Map Arithmetic to AST**

```rust
match op {
    Operator::I32Add => {
        let (r, l) = (self.pop(), self.pop());
        self.push(Expr::BinOp(BinOp::Add, Box::new(l), Box::new(r)));
    }
}

```

**Step 2: Map Locals (GLSL Variables)**

```rust
Operator::LocalSet { local_index } => {
    let val = self.pop();
    self.current_block.push(Stmt::Assign(local_index, val));
}

```

**Step 3: Handle Branching (`br`)**
In WASM, `br 0` means "jump to the end of the current block." In your GLSL emitter, this becomes a `break;`.

* **If it's a Loop:** `br 0` is a `continue;`.
* **If it's a Block:** `br 0` is a `break;`.

### 4. Vector (SIMD) Lifting for GLSL

Since you want GLSL-like output, you should intercept `v128` instructions immediately and map them to `vec4`.

```rust
Operator::F32x4Add => {
    let (r, l) = (self.pop(), self.pop());
    self.push(Expr::VecOp(VecOp::Add, Box::new(l), Box::new(r)));
}

```

### Summary of Phase 2 logic:

1. **Iterate** through `wasmparser` operators.
2. **Simulate** the value stack (`Vec<Expr>`).
3. **Track** nesting depth with a `control_stack`.
4. **Emit** a `Stmt` (Statement) whenever the stack value is assigned to a local or a memory address.
5. **Accumulate** these `Stmt` nodes into a `FunctionAST` struct.


## Phase 2.1: Handling `If` / `Else` Control Flow

Phase 2 requires a "Two-Stack" approach to handle the way WebAssembly merges stack machine logic with structured blocks like `if` and `else`.

The most pragmatic way to implement this is to treat `if` as a container that "captures" the symbolic stack's top value as its condition.

---

### 1. Step: Define the Control Frame

You need a stack to track nesting. Each frame needs to know its type and how high the value stack was when it started.

```rust
enum Frame { 
    If { cond: Expr, then_body: Vec<Stmt> },
    Else { then_body: Vec<Stmt>, else_body: Vec<Stmt> },
    Block { body: Vec<Stmt> } 
}
let mut control_stack: Vec<Frame> = vec![];

```

### 2. Step: Entering the `If` Block

When `wasmparser` hits `Operator::If`, it expects a condition to be on the value stack already. You must "pop" it and start a new frame.

```rust
Operator::If { .. } => {
    let condition = self.value_stack.pop()?;
    control_stack.push(Frame::If { 
        cond: condition, 
        then_body: vec![] 
    });
}

```

### 3. Step: Switching to `Else`

The `Else` operator tells you that the "Then" part is finished. You don't pop the frame yet; you transform it.

```rust
Operator::Else => {
    let frame = control_stack.pop()?;
    if let Frame::If { cond, then_body } = frame {
        control_stack.push(Frame::Else { 
            then_body, 
            else_body: vec![] 
        });
    }
}

```

### 4. Step: Closing with `End`

The `End` operator finishes the current innermost block. You must pop the frame and "emit" it as a finished statement into the parent block.

```rust
Operator::End => {
    let finished_frame = control_stack.pop()?;
    let stmt = match finished_frame {
        Frame::If { cond, then_body } => Stmt::If(cond, then_body, None),
        Frame::Else { then_body, else_body } => Stmt::If(.., then_body, Some(else_body)),
        _ => Stmt::Block(..)
    };
    self.current_block().push(stmt);
}

```

### 5. Step: Handling Expressions in `If`

In GLSL (and WASM), an `if` can return a value (like a ternary). If your `If` frame has a `result_type`, the last expression in both the `then` and `else` blocks should be popped from their local "simulated" stacks and pushed onto the parent's `value_stack`.

---

### Summary of Sub-Phase 2 Implementation

1. **Condition Capture**: Pop the value stack immediately upon entering an `if`.
2. **Instruction Routing**: While a frame is active, all new `Stmt` nodes go into that frameâ€™s `body` vector, not the main function.
3. **Frame Transformation**: `Else` is the pivot point where you stop filling `then_body` and start filling `else_body`.
4. **Statement Lifting**: `End` converts the entire captured frame into a single `Stmt::If` node in the parent scope.




## Phase 3: The Simplifier (using `egg`)


Phase 3 is the "Refiner." Without it, your decompiler will produce technically correct but unreadable "spaghetti" code like `(x + 0) * 1` or `local_1 = 5; local_2 = local_1 + 2;`.

We will use the **`egg`** (e-graphs good) crate to perform **Equality Saturation**. This allows the decompiler to "search" for the most readable version of an expression based on rules you provide.

---

### 1. Functional Blocks

* **The Language Definition**: A trait implementation that tells `egg` how to navigate your `Expr` enum.
* **The Rule Set**: A collection of "Rewrites" (e.g., `x + 0 => x`).
* **The Cost Function**: A logic block that tells `egg` that `x << 1` is "cheaper" (more readable) than `x * 2` in a graphics context, or vice versa.
* **The Runner**: The engine that takes your messy AST and spits out the simplified one.

---

### 2. Step 1: Define the `egg::Language`

You must allow `egg` to see your `Expr` enum. You do this by deriving `Language`.

```rust
use egg::*;
define_language! {
    pub enum WasmLang {
        "+" = Add([Id; 2]),
        "*" = Mul([Id; 2]),
        "<<" = Shl([Id; 2]),
        Num(i32),
        Symbol(Symbol),
    }
}

```

### 3. Step 2: Create Rewrite Rules

These are the "cleanup" instructions. For GLSL, you want to simplify math and potentially collapse bitwise operations.

```rust
let rules: &[Rewrite<WasmLang, ()>] = &[
    rewrite!("commute-add"; "(+ ?a ?b)" => "(+ ?b ?a)"),
    rewrite!("add-0"; "(+ ?a 0)" => "?a"),
    rewrite!("mul-2-to-shl"; "(* ?a 2)" => "(<< ?a 1)"),
    rewrite!("fold-add"; "(+ ?a ?b)" => { 
        /* logic to sum constants */ 
    }),
];

```

### 4. Step 3: Run the Optimizer

You pass your "dirty" AST into an `egg::Runner`. It explores all possible versions of the code that are logically equivalent.

```rust
let runner = Runner::default().with_expr(&dirty_expr).run(rules);
let (best_cost, best_expr) = Extractor::new(
    &runner.egraph, 
    AstSize // Prefer the smallest/shortest code
).find_best(runner.roots[0]);

```

---

### 5. Caveats & Expert Advice

* **The "Explosion" Risk**: Equality saturation can be memory-intensive. If you have too many "commute" rules (like `a+b => b+a`), `egg` might explore billions of permutations. **Advice**: Limit the "Node Limit" in your runner to prevent it from hanging on complex functions.
* **Side Effects are Forbidden**: `egg` is for **pure mathematical expressions**. Never put a `Call` or a `MemoryWrite` into an `egg` rewrite rule unless you are 100% sure it has no side effects. If you simplify `call_func() + 0` to `call_func()`, it's safe. If you simplify `call_func() * 0` to `0`, you just deleted a function call that might have been important.
* **GLSL Context Matters**: In GLSL, `a * 0.5` is often better than `a / 2.0` because multiplication is faster on many GPUs. Tailor your "Cost Function" to prefer GPU-friendly patterns.

---

### 6. Phase 3 Summary Table

| Task | Component | Benefit |
| --- | --- | --- |
| **Algebraic Cleanup** | `egg` Rules | Removes `+0`, `*1`, and double negatives. |
| **Constant Folding** | `egg` Analysis | Turns `2 + 3` into `5` automatically. |
| **Code Compaction** | `AstSize` Cost | Ensures the output is the shortest possible version. |
| **Pattern Matching** | Rewrites | Detects complex patterns like `(x << 16) >> 16` as `(short)x`. |



## Phase 3.1: Advanced Vector "Lifting" with `egg`

To simplify multiple scalar operations into a single vector operation (e.g., turning three `f32` adds into one `vec3` add), you need to move beyond simple algebraic identities and use **structural pattern matching**.

This is the most "magical" part of using `egg` for a GLSL decompiler.

### 1. Step: The Vector AST Node

First, ensure your `WasmLang` can represent a "Constructor" (like `vec3(...)`).

```rust
define_language! {
    pub enum WasmLang {
        "vec3" = Vec3([Id; 3]),
        "vadd" = VecAdd([Id; 2]),
        // ... standard ops
    }
}

```

### 2. Step: The "Vectorization" Rule

You define a rule that looks for a `vec3` where every component is being modified by the same operation. This is essentially **SIMD lifting at the AST level**.

```rust
rewrite!("lift-vec3-add"; 
    "(vec3 (+ ?a1 ?b1) (+ ?a2 ?b2) (+ ?a3 ?b3))" 
    => 
    "(vadd (vec3 ?a1 ?a2 ?a3) (vec3 ?b1 ?b2 ?b3))"
)

```

### 3. Step: Handling the Cost Function

In a decompiler, "Best" usually means "Most Idiomatic." You must tell `egg` that one `vadd` is "cheaper" than three `+` nodes.

```rust
struct GLSLCost;
impl CostFunction<WasmLang> for GLSLCost {
    type Cost = usize;
    fn cost<S>(&mut self, enode: &WasmLang, mut costs: S) -> usize 
    where S: FnMut(Id) -> usize {
        let op_cost = match enode {
            WasmLang::VecAdd(_) => 1, // High value, low cost
            WasmLang::Add(_) => 2,    // Individual adds are "expensive"
            _ => 1,
        };
        op_cost + enode.fold_list(0, |a, id| a + costs(id))
    }
}

```

### 4. Caveats: Swizzling and Alignment

* **The Component Problem**: WASM often stores vectors as four separate `f32` locals. You must first "collect" these into a `vec4` node before `egg` can run the rules above.
* **Swizzling**: If the WASM code does `vec.yzwx`, your rules need to account for permutations. This is why `egg` is powerful; it will try all permutations to see if any match your `vadd` rule.

### 5. Summary of Phase 3 "Lifting"

1. **Collect**: Identify groups of locals that are used together (e.g., `local.get 1, 2, 3`).
2. **Synthesize**: Wrap them in a pseudo-constructor like `vec3`.
3. **Saturate**: Let `egg` apply rules to see if that `vec3` can be expressed as a single operation.
4. **Extract**: Pick the version that uses the fewest total operations.

---

## Phase 4: The Final Step (Emission)

Phase 4 is straightforward: you write a recursive "Printer" that visits your optimized `egg` tree and prints strings.

* `VecAdd(a, b)` prints as `(a + b)`.
* `Vec3(a, b, c)` prints as `vec3(a, b, c)`.

Phase 4 is where your internal mathematical representation becomes code that a human can read and a compiler can execute. Since WebAssembly (WASM) is often "flatter" than GLSL, you must carefully reconstruct scoping and handle the quirks of shader languages.

### 1. The Functional Blocks

* **The Symbol Table**: Maps WASM local indices (e.g., `local 1`) to meaningful GLSL names (e.g., `v1`).
* **The Type Resolver**: Ensures `1.0 + 2` is printed as `1.0 + 2.0` (GLSL is strict about float/int mixing).
* **The Recursive Printer**: Walks the AST and handles indentation, semicolons, and curly braces.

### 2. Checklist of Critical Edge Cases

#### A. Variable Shadowing & Naming

WASM locals are just indices. In GLSL, you need names.

* **The Risk**: Reusing a name in a nested block that was defined in an outer block.
* **Advice**: Use a prefix like `v_` + index. If a WASM local is redefined, check if it was previously used in a different scope; if so, you may need to "re-declare" it or use an assignment.

#### B. Float Promotion (The `.0` Problem)

GLSL will fail to compile `float x = 1 + 2.0;`.

* **The Risk**: WASM handles numeric conversions implicitly in some ops, but GLSL does not.
* **Advice**: During emission, check the expected type of a `BinaryOp`. If one side is a float, ensure the other side is printed with a decimal point.

#### C. Memory Access (SSBOs vs. Linear Memory)

WASM treats memory as one big array. GLSL uses Storage Buffers.

* **The Risk**: `i32.load(ptr)` has no direct equivalent if you don't know which buffer it's in.
* **Advice**: Define a standard `layout` for your memory in the header of your output. Map `load/store` to an array access: `memory_buffer[ptr >> 2]`.

#### D. The "Phi" Node Problem

WASM can leave values on the stack at the end of an `if` block.

* **The Risk**: GLSL `if` statements cannot return values.
* **Advice**: Use a temporary variable.
* **WASM**: `val = if (cond) { 5 } else { 10 }`
* **GLSL Port**: `int temp; if(cond) { temp = 5; } else { temp = 10; } val = temp;`



### 3. Step-by-Step Emission Logic

1. **Header**: Print `#version 450` and any required `layout(std430, binding = 0)` buffers.
2. **Locals**: Scan the function body and declare all used locals at the top (e.g., `float v0, v1;`).
3. **Traverse**: Start at the root of your optimized AST.
* For `Stmt::Assign`, print `name = value;`.
* For `Expr::BinOp`, print `(left op right)`.
* For `Stmt::If`, print `if (cond) { body }`.


4. **Formatting**: Track an `indent_level` (increment on `{`, decrement on `}`).

### 4. GLSL Versioning Caveat

Different GLSL versions have different rules (e.g., `attribute` vs `in`).

* **Advice**: Target **GLSL ES 3.1** or **4.5** for maximum compatibility with WebGPU/Vulkan. Use a `Config` struct in your Emitter to toggle version-specific keywords.

```rust
struct EmitterConfig {
    glsl_version: u32, // e.g., 450
    use_vulkan_flavor: bool,
}

```

### Final Project Checklist

* [ ] **Phase 1**: `wasmparser` loop + custom `Expr` enum.
* [ ] **Phase 2**: Two-stack lifter (Value stack + Control stack).
* [ ] **Phase 3**: `egg` rules for `+0` and `vec3` vectorization.
* [ ] **Phase 4**: Recursive string printer with float-type awareness.

