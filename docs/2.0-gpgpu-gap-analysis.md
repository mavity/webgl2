
Based on a systematic review of the graph kernels and the current state of our WebGL2 emulation, here is the assessment.

### Executive Summary: **Partial Support with Major Blockers**
While the backend handles complex GLSL features like loops, binary search, and texture fetching well, the **GPGPU pipeline orchestration** in these kernels relies on several WebGL2 features currently missing or stubbed in our implementation.

---

### 1. Feature Support Matrix

| WebGL2 Feature | Kernel(s) using it | Status in Project | Impact |
| :--- | :--- | :--- | :--- |
| **MRT (Multiple Render Targets)** | `Reshuffle`, `Simulation`, `SortEncoder`, `Sentinel` | ❌ **NOT SUPPORTED** | **Critical Blocker.** The backend only captures 1 color output. These kernels expect to write up to 8 targets simultaneously. |
| **`gl.drawBuffers`** | `Reshuffle`, `Simulation`, `SortEncoder`, `Sentinel` | ❌ **STUBBED** | **Critical Blocker.** The JS API explicitly throws a "not implemented" error. |
| **`gl.clearBufferfv`** | `KIdentityMirror` | ❌ **MISSING** | **Blocker.** This function is not implemented in the JS wrapper or Rust FFI. |
| **`gl.getExtension`** | `GraphLayout` (for `EXT_color_buffer_float`) | ❌ **STUBBED** | **Blocker** for initial setup. While the kernels log an error and continue, floating-point writes are required for physics. |
| **`gl.POINTS` / `gl_PointSize`** | `KIdentityMirror` | ⚠️ **PARTIAL** | The rasterizer executes `gl.POINTS` but ignores the `gl_PointSize` builtin in the shader, potentially leading to missing samples. |
| **`gl_VertexID`** | `KIdentityMirror` | ❌ **MISSING** | **Blocker.** The WASM backend does not currently map `BuiltIn::VertexIndex` to a valid input, breaking vertex-pulling logic. |
| **Integer Textures (`RGBA32UI`)** | `KSortEncoder` | ⚠️ **PARTIAL** | Mapping for `UI` formats is missing in `gl_to_wgt_format`, which will likely default them to `RGBA8`. |
| **Shader Loops & `texelFetch`** | Almost all kernels | ✅ **SUPPORTED** | The Naga/WASM backend successfully handles the complex control flow and direct texel access used in the prefix sum and binary search. |

---

### 2. Detailed Kernel Assessment

#### ✅ Kernels Likely to Work (Single-Pass/Single-Target)
*   **`KEdgeCoarseMap`**: Uses a binary search over an `R32F` texture. This should work as it uses a single `layout(location=0)` output.
*   **`KEdgePrefixSum`**: Performs multiple passes of Hillis-Steele scan. Since each pass writes to a single target, it should function correctly, though performance may be impacted by the high pass count.
*   **`KEdgeRelocation`**: Relocates edges using a linear scan and coarse map. Single-target output means it should translate correctly.

#### ❌ Kernels that will Fail (MRT & Built-ins)
*   **`KSortEncoder`**: This is the biggest failure point. It attempts to write **8 `uvec4` targets** in a single pass to encode the sort order. Our system will only capture the first output, corrupting the sort registry.
*   **`KPhysicsSimulation` / `KParticleReshuffle`**: Both kernels use MRT to update Position, Velocity, and Metadata in a single draw call. Only Position would be updated in our current state.
*   **`KIdentityMirror`**: Relies on `gl_VertexID` to map particles to their persistent IDs (the "phonebook" logic). Without `VertexID` and `clearBufferfv`, the identity map will remain empty/garbage.
*   **`KPhysicsSentinel`**: Uses MRT and `drawBuffers` to validate state; it will throw an error immediately upon execution.

### 3. Recommendation
Our current WebGL2 implementation cannot support the **Mavity Graph Layout** without significant upgrades to the following areas:
1.  **MRT Support**: Expand `FramebufferObj` and the `Rasterizer` to handle multiple color attachments.
2.  **Built-in Mapping**: Map `VertexIndex` and `PointSize` in the `naga_wasm_backend`.
3.  **API Surface**: Implement `drawBuffers`, `clearBufferfv`, and basic extension query support.

