# 1.1.3 â€” Distilled Coverage (WASM Instrumentation)

**Status:** Approved Plan

## ðŸŽ¯ Goal
Implement a "force-feeding" coverage mechanism that moves complexity to build-time.
- **No runtime inspectors** (V8/Chrome DevTools Protocol).
- **No unstable toolchains** (works on stable Rust).
- **Zero-config runtime** (WASM module reports its own coverage).

## ðŸ— Architecture (Pointer Patching)

We integrate the coverage logic directly into the `webgl2` library using a "Pointer Patching" strategy. The Rust code defines pointers that are initially null, and the build tool allocates the necessary memory and patches the pointers.

1.  **The Library (Rust):**
    *   Defines `static mut COV_PTR: *mut u8`.
    *   Defines `static mut COV_LEN: usize`.
    *   Exports `get_lcov_report()` which reads from `COV_PTR`.
2.  **The Distiller (Build CLI):**
    *   **Analysis:** Parses DWARF to generate the mapping and count code points.
    *   **Allocation:** Appends a new **Data Segment** to the WASM binary containing the mapping data and zeroed space for hits.
    *   **Patching:** Updates `COV_PTR` and `COV_LEN` in the binary to point to this new segment.
    *   **Instrumentation:** Injects code to write to the "Hit" portion of the new segment.
3.  **The Harness (JS):** Calls `get_lcov_report()` as before.

## ðŸ“¦ Dependencies

Same as before (`walrus`, `gimli`), but only for the CLI tool. The runtime has **zero** extra dependencies.

---

## Phase 1: The Library (Rust Implementation)

We add a `coverage` module (guarded by a feature flag) to `src/lib.rs`.

```rust
// src/coverage.rs

#[no_mangle]
static mut COV_PTR: *mut u8 = std::ptr::null_mut();

#[no_mangle]
static mut COV_LEN: usize = 0;

#[no_mangle]
pub extern "C" fn get_lcov_report() -> *const u8 {
    unsafe {
        if COV_PTR.is_null() { return std::ptr::null(); }
        let data = std::slice::from_raw_parts(COV_PTR, COV_LEN);
        
        // Data Layout: [ Mapping Table (N bytes) | Hit Buffer (M bytes) ]
        // 1. Parse Mapping Table from start of 'data'
        // 2. Scan Hit Buffer (offset by N)
        // 3. Generate and return LCOV string
    }
}
```

## Phase 2: The Distiller (The Allocator & Patcher)

The `distill_wasm` tool manages the memory layout.

### 2.1 Analysis & Layout
1.  Parse DWARF to build the `ID â†’ File:Line` map.
2.  Serialize the map into a byte buffer (size `N`).
3.  Determine number of instrumentation points (size `M`).
4.  Total required size = `N + M`.

### 2.2 Allocation (Append Data Segment)
1.  **Find Heap Base:** Locate the `__heap_base` global.
    *   *Requirement:* The WASM must have the `name` section or export `__heap_base`.
2.  **Calculate Offset:** Read the current value of `__heap_base` (this is the end of static memory).
3.  **Append Segment:** Create a new **Active Data Segment** at this offset.
    *   Content: `[ Serialized Map | Zeros(M) ]`
4.  **Update Heap Base:** Update the `__heap_base` global's initializer to `Old_Base + N + M`.
    *   *Critical:* This prevents the memory allocator (dlmalloc/wee_alloc) from overwriting our coverage data.

### 2.3 Patching
1.  Find the addresses of `COV_PTR` and `COV_LEN` symbols.
2.  Overwrite their initial values in the binary's data section:
    *   `COV_PTR` = Address of new segment.
    *   `COV_LEN` = `N + M`.

### 2.4 Instrumentation
Iterate the code and inject probes.
*   **Hit Address:** `Segment_Address + N + ID`
*   **Instruction:** `i32.store8(Hit_Address, 1)`

---

## Phase 3: Testing Strategy

---

## Phase 3: Testing Strategy (JS Unit Tests)

We will **not** verify exact line numbers in unit tests, as they change with code edits. Instead, we use **Spot-Checks** to verify that specific APIs trigger coverage in specific files.

### 3.1 Test Harness Example

```javascript
import { expect } from 'chai';
import { instantiate } from './loader.js';

it('covers texture logic when createTexture is called', () => {
    const instance = instantiate();
    instance.exports.createTexture(); // Invoke API
    
    const lcov = readWasmString(instance.exports.get_lcov_report());
    
    // Spot-check: Ensure the texture file is present in coverage
    expect(lcov).to.contain('SF:src/webgl2_texture.rs');
    // Spot-check: Ensure *some* lines were hit (DA:...,1)
    expect(lcov).to.match(/DA:\d+,1/); 
});
```

### 3.2 Verification Rules
1.  **Presence:** Does the expected source file appear in the report?
2.  **Activity:** Are there non-zero hits for that file?
3.  **No Flakiness:** Do not assert `DA:42,1` (exact line 42). Assert `DA:*,1` exists for the file.
