# WASM ABI for shader modules

This document describes a minimal, portable ABI for shader WebAssembly modules
that run unchanged in Browser and Node environments (and in native hosts via
adapters). The goal is a single non-WASI wasm file that works across hosts.

## Goals

- Single wasm artifact (no WASI) that can be loaded with WebAssembly.instantiate
  in browsers and Node.
- Small, stable import set under module `env` that host adapters implement.
- Data exchanged via linear memory and simple i32/f32/f64 primitives.
- DWARF and custom sections may be embedded in the wasm file for debugging.

## Memory

- Linear memory is used for all higher-level data.
- Either the module imports memory (`env.memory`) or it exports memory as
  `memory`. Host adapters should accept both patterns and prefer exported
  memory when present.
- Memory layout conventions (recommended defaults):
  - 0x0000: stack / reserved
  - 0x1000: attributes
  - 0x2000: uniforms
  - 0x3000: varyings
  - 0x4000: out / temporary / return buffer

These offsets are just a convention; callers and module code must agree on
offsets or implement `alloc`/`free` host calls.

## Imports (module: `env`)

The module should import the following host functions (names are suggestions
and must match host adapters):

- `memory` (optional): WebAssembly.Memory

- `texture_sample(texture_id: i32, u: f32, v: f32, out_ptr: i32) -> void`
  - Host samples the specified texture and writes 4×f32 RGBA at `out_ptr`.

- `log(level: i32, ptr: i32, len: i32) -> void`
  - Host prints `len` bytes from linear memory at `ptr` as UTF-8 with the
    specified `level` (0=error,1=warn,2=info).

- `now_ms() -> f64`
  - Returns current time in milliseconds as f64 (optional convenience).

Optional (for dynamic memory management):

- `alloc(size: i32) -> i32`
- `dealloc(ptr: i32, size: i32) -> void`

If `alloc`/`dealloc` are provided by the host, the module can request memory
blocks; otherwise the module should use fixed offsets agreed with the host.

## Exports (suggested)

- `vertex_main(attr_ptr: i32, uniform_ptr: i32, out_ptr: i32) -> void`
  - Execute vertex shader for a single vertex. Writes position (4×f32) to
    `out_ptr`.

- `fragment_main(varyings_ptr: i32, uniform_ptr: i32, out_ptr: i32) -> void`
  - Execute fragment shader for a single pixel. Writes color (4×f32) to
    `out_ptr`.

Notes:
- Instead of multi-value returns, using an `out_ptr` is more portable.
- You may expose additional helpers for batching or specialized entry points.

## Host responsibilities

- Provide `env` imports that the module expects.
- Manage textures and write sampled pixels into the module's memory.
- For debugger integration, ensure DWARF custom sections are preserved when
  serving the wasm file.

## Example host behavior (high-level)

- Browser: call `WebAssembly.instantiate(wasmBytes, { env: { memory, texture_sample, log, now_ms }})`.
- Node: call `WebAssembly.instantiate(wasmBytes, { env })` or `compile+instantiate`.
- Wasmtime/Native: create `Linker`, define functions `env::texture_sample`, set memory and instantiate.

## Debugging

- Embed DWARF in the wasm file (.debug_* sections). Chrome/Edge DevTools and
  Firefox can display sources when DWARF maps are present.
- Preserve section names and do not strip debug sections when distributing
  debug-enabled wasm.

## Rationale

- Avoiding WASI maximizes portability to browsers and keeps the shader module
  focused on shader semantics and host-provided services like texture sampling.
- Linear-memory + pointer ABI is simple and works reliably across engines.

## Next steps

- Implement a unified JS adapter that provides `env` for browser and Node
  (done: `runners/adapter.js`).
- Implement a Rust adapter for Wasmtime if native testing is required later.

