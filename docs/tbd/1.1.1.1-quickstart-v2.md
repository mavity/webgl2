# WebGL2 Prototype v2 - Quick Start Guide

## Overview

The implementation provides a clean, spec-compliant WebGL2 prototype with:
- **Rust backend** (`src/webgl2_context.rs`): Owns all runtime state (contexts, textures, framebuffers)
- **JavaScript wrapper** (`index2.js`): `WasmWebGL2RenderingContext` class that forwards calls to WASM
- **WASM exports**: 15+ functions for context/texture/framebuffer operations

## Installation & Build

### Build WASM
```bash
npm run build:wasm
```
Produces: `webgl2.wasm` in repo root

### Run Tests
```bash
npm run test:smoke
```
Full pipeline: build → test → verify pixel round-trip

## Usage (JavaScript)

### Basic Example
```javascript
const { webGL2 } = require('./index2.js');

async function main() {
  // Create a context
  const gl = await webGL2();
  
  // Create and upload a texture
  const tex = gl.createTexture();
  gl.bindTexture(0, tex);
  
  const pixelData = new Uint8Array([
    255, 0, 0, 255  // RGBA: red
  ]);
  gl.texImage2D(0, 0, 0, 1, 1, 0, 0, 0, pixelData);
  
  // Create framebuffer and attach texture
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(0, fb);
  gl.framebufferTexture2D(0, 0, 0, tex, 0);
  
  // Read pixels back
  const out = new Uint8Array(4);
  gl.readPixels(0, 0, 1, 1, 0, 0, out);
  
  console.log(`Pixel: R=${out[0]}, G=${out[1]}, B=${out[2]}, A=${out[3]}`);
  
  // Always destroy to free WASM resources
  gl.destroy();
}

main().catch(console.error);
```

### API Reference

#### Factory
- `webGL2(opts)` → Promise<WasmWebGL2RenderingContext>
  - Auto-loads `webgl2.wasm`
  - Creates context via `wasm_create_context()`

#### Context Lifecycle
- `gl.destroy()` → void
  - Frees all resources, invalidates context
  - After calling, all methods throw

#### Textures
- `gl.createTexture()` → u32 (handle)
  - Allocate a new texture in the context
- `gl.deleteTexture(tex)` → void
  - Free a texture
- `gl.bindTexture(target, tex)` → void
  - `target`: ignored
  - `tex`: handle or 0 to unbind
- `gl.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels)` → void
  - `pixels`: Uint8Array (RGBA u8) or null
  - Uploads to currently bound texture
  - Throws on error

#### Framebuffers
- `gl.createFramebuffer()` → u32 (handle)
  - Allocate a new framebuffer
- `gl.deleteFramebuffer(fb)` → void
  - Free a framebuffer
- `gl.bindFramebuffer(target, fb)` → void
  - `target`: ignored
  - `fb`: handle or 0 to unbind
- `gl.framebufferTexture2D(target, attachment, textarget, texture, level)` → void
  - Attaches texture to currently bound framebuffer
  - `target`, `attachment`, `textarget`, `level`: mostly ignored

#### Pixel Operations
- `gl.readPixels(x, y, width, height, format, type, out)` → void
  - Reads from currently bound framebuffer
  - `out`: Uint8Array (must be width*height*4 bytes)
  - Fills `out` with RGBA u8 pixel data
  - Throws on error

## Error Handling

All operations may throw with descriptive error messages:
```javascript
try {
  const tex = gl.createTexture();
} catch (e) {
  console.error(`Failed: ${e.message}`);
  // Example: "WASM error 2: out of memory"
}
```

Error codes (from WASM):
- 0: OK
- 1: ERR_INVALID_HANDLE
- 2: ERR_OOM (out of memory)
- 3: ERR_INVALID_ARGS
- 4: ERR_NOT_IMPLEMENTED
- 5: ERR_GL (graphics error)
- 6: ERR_INTERNAL (internal error)

## Memory Management

The JS side handles all WASM memory allocation:
- Uploads: `wasm_alloc()` → write data → call WASM → `wasm_free()`
- Readbacks: `wasm_alloc()` → call WASM → read data → `wasm_free()`

This is transparent to the caller; just pass Uint8Array buffers.

## Design Notes

### Single Context
Currently, `webGL2()` creates one context. To support multiple contexts:
```javascript
const gl1 = await webGL2();
const gl2 = await webGL2();
// Both work independently
gl1.destroy();
gl2.destroy();
```

### Thread Safety
WASM is single-threaded. All registry operations are synchronized via `RefCell` (no Mutex needed).

### No Emulation
All WebGL semantics are implemented in Rust. JS is purely a forwarder:
- No client-side framebuffer storage
- No shader compilation
- No validation beyond basic checks

## Testing

### Smoke Test
```bash
npm run test:smoke
```
Validates:
1. Context creation
2. Texture upload/download
3. Framebuffer attachment
4. Pixel readback verification

### Manual Test
```bash
node index2.js
```
Runs built-in demo; same test as smoke.js.

## File Structure

```
webgl2/
├── src/
│   ├── lib.rs              (15 new WASM exports)
│   └── webgl2_context.rs   (core implementation, 500+ lines)
├── index2.js               (JS class + factory, 470+ lines)
├── test/
│   └── smoke.js            (end-to-end test)
├── webgl2.wasm             (built artifact)
├── package.json            (updated with test:smoke)
└── IMPLEMENTATION_V2.md    (detailed reference)
```

## Constraints & Limitations

1. **No shader support yet**: Can only manipulate textures/framebuffers
2. **No rendering**: No rasterization or draw calls (MVP focus: resource pipeline)
3. **No batching**: Each operation is a separate WASM call
4. **No async**: All operations are synchronous
5. **Limited targets**: `target` parameter is ignored (assumes TEXTURE_2D/FRAMEBUFFER)
6. **Single framebuffer**: Only one bound at a time per context

## Roadmap

- [ ] Shader programs (glCreateProgram, glLinkProgram, etc.)
- [ ] Draw calls (glDrawArrays, glDrawElements)
- [ ] Buffers (glGenBuffers, glBufferData, etc.)
- [ ] Clear operations (glClear, glClearColor)
- [ ] Viewport/scissor
- [ ] Multiple render targets
- [ ] Performance optimizations
- [ ] CI/GitHub Actions

## Troubleshooting

### "WASM not found at webgl2.wasm"
```bash
npm run build:wasm
```

### "Failed to fetch webgl2.wasm" (browser)
Ensure `webgl2.wasm` is served from the same directory as `index2.js`.

### Memory errors
Check that:
- All textures are created before binding
- Framebuffers have attached textures before readback
- Output buffers for readPixels are correctly sized (width*height*4 bytes)

### Context destroyed errors
Ensure you don't call methods after `gl.destroy()`.

## Questions?

See `IMPLEMENTATION_V2.md` for:
- Complete API documentation
- Design decisions
- Compliance checklist
- Code structure overview
