# Naga IR â†’ WASM Backend Implementation Plan

**Document Version:** 1.0  
**Date:** November 8, 2025  
**Status:** Architecture Proposal - Adopted

---

## ğŸ¯ Executive Summary

This document details the implementation strategy for building a **Naga IR â†’ WASM Backend** with full DWARF debugging support. This approach replaces the original custom IR design with the proven Naga infrastructure from the wgpu/WebGPU ecosystem, significantly reducing project risk while improving debugging capabilities.

**Key Decision:** Use Naga as the shader IR and build a custom WASM backend that emits DWARF debug information for browser DevTools integration.

---

## ğŸ—ï¸ Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Developer Workflow                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  GLSL Source (.vert, .frag)                                     â”‚
â”‚         â†“                                                        â”‚
â”‚  Naga Frontend (Parser + Validator)                             â”‚
â”‚         â†“                                                        â”‚
â”‚  Naga IR (Validated, Optimized)                                 â”‚
â”‚         â†“                                                        â”‚
â”‚  Custom WASM Backend (THIS PROJECT)                             â”‚
â”‚         â†“                                                        â”‚
â”‚  WASM Module + DWARF Debug Info                                 â”‚
â”‚         â†“                                                        â”‚
â”‚  Software Rasterizer (Emulator)                                 â”‚
â”‚         â†“                                                        â”‚
â”‚  Browser DevTools (Step-through debugging)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Component Responsibilities**

| Component | Responsibility | Owned By |
|-----------|---------------|----------|
| **GLSL Frontend** | Parse GLSL â†’ Naga IR | Naga (existing) |
| **IR Validation** | Type checking, bounds checking | Naga (existing) |
| **IR Optimization** | Dead code elimination, constant folding | Naga (existing) |
| **WASM Backend** | IR â†’ WASM instructions | **This project (NEW)** |
| **DWARF Generation** | Debug info for DevTools | **This project (NEW)** |
| **Emulator Runtime** | Execute WASM, texture sampling | **This project** |
| **Codegen Tool** | Generate JS/TS harness | **This project** |

---

## ğŸ“ Repository Structure

```
webgl2/
â”œâ”€â”€ Cargo.toml                    # Workspace configuration
â”œâ”€â”€ README.md                     # Project overview
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ 1-plan.md                # Original project plan
â”‚   â”œâ”€â”€ 1.1-ir-wasm.md           # This document
â”‚   â”œâ”€â”€ 2-naga-backend-api.md    # Backend implementation spec
â”‚   â””â”€â”€ 3-dwarf-spec.md          # DWARF generation guide
â”‚
â”œâ”€â”€ crates/
â”‚   â”œâ”€â”€ naga-wasm-backend/       # Core: Naga IR â†’ WASM compiler
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ lib.rs           # Public API
â”‚   â”‚   â”‚   â”œâ”€â”€ backend.rs       # WASM code generation
â”‚   â”‚   â”‚   â”œâ”€â”€ types.rs         # Type system mapping
â”‚   â”‚   â”‚   â”œâ”€â”€ expressions.rs   # Expression translation
â”‚   â”‚   â”‚   â”œâ”€â”€ control_flow.rs  # If/Loop/Block translation
â”‚   â”‚   â”‚   â”œâ”€â”€ builtins.rs      # GLSL built-in functions
â”‚   â”‚   â”‚   â””â”€â”€ debug/
â”‚   â”‚   â”‚       â”œâ”€â”€ dwarf.rs     # DWARF generation
â”‚   â”‚   â”‚       â”œâ”€â”€ spans.rs     # Source location tracking
â”‚   â”‚   â”‚       â””â”€â”€ variables.rs # Variable info preservation
â”‚   â”‚   â””â”€â”€ tests/
â”‚   â”‚       â”œâ”€â”€ simple_shaders.rs
â”‚   â”‚       â””â”€â”€ dwarf_output.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ wasm-gl-emu/             # Software rasterizer & runtime
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ state.rs         # WebGL2 state machine
â”‚   â”‚   â”‚   â”œâ”€â”€ rasterizer.rs    # Triangle rasterization
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime.rs       # WASM shader execution
â”‚   â”‚   â”‚   â”œâ”€â”€ texture.rs       # Texture sampling (host fn)
â”‚   â”‚   â”‚   â”œâ”€â”€ framebuffer.rs   # Render target management
â”‚   â”‚   â”‚   â””â”€â”€ pipeline.rs      # Vertex â†’ Fragment flow
â”‚   â”‚   â””â”€â”€ tests/
â”‚   â”‚
â”‚   â”œâ”€â”€ glsl-introspection/      # Parser for annotations + codegen
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ parser.rs        # Naga wrapper + annotation parsing
â”‚   â”‚   â”‚   â”œâ”€â”€ annotations.rs   # @buffer_layout, @uniform_group
â”‚   â”‚   â”‚   â””â”€â”€ manifest.rs      # Resource manifest generation
â”‚   â”‚   â””â”€â”€ tests/
â”‚   â”‚
â”‚   â”œâ”€â”€ js-codegen/              # TypeScript harness generator
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ templates/       # Tera/Handlebars templates
â”‚   â”‚   â”‚   â”œâ”€â”€ generator.rs     # Code generation logic
â”‚   â”‚   â”‚   â””â”€â”€ types.rs         # TypeScript type mapping
â”‚   â”‚   â””â”€â”€ tests/
â”‚   â”‚
â”‚   â””â”€â”€ webgl2-cli/              # Command-line interface
â”‚       â”œâ”€â”€ Cargo.toml
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â””â”€â”€ main.rs          # CLI entry point
â”‚       â””â”€â”€ README.md
â”‚
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ 01-triangle/
â”‚   â”‚   â”œâ”€â”€ shader.vert
â”‚   â”‚   â”œâ”€â”€ shader.frag
â”‚   â”‚   â”œâ”€â”€ main.js
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ 02-textured-quad/
â”‚   â”œâ”€â”€ 03-lighting/
â”‚   â””â”€â”€ 04-debug-session/        # Debugging tutorial
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ conformance/             # WebGL2 conformance subset
â”‚   â”œâ”€â”€ integration/             # End-to-end tests
â”‚   â””â”€â”€ fixtures/                # Test shaders
â”‚
â””â”€â”€ tools/
    â”œâ”€â”€ dwarf-inspector/         # Debug DWARF output
    â””â”€â”€ wasm-validator/          # Validate generated WASM
```

---

## ğŸ“¦ Core Dependencies

### **Workspace `Cargo.toml`**

```toml
[workspace]
members = [
    "crates/naga-wasm-backend",
    "crates/wasm-gl-emu",
    "crates/glsl-introspection",
    "crates/js-codegen",
    "crates/webgl2-cli",
]
resolver = "2"

[workspace.package]
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
authors = ["WebGL2 Platform Team"]

[workspace.dependencies]
# Core shader infrastructure
naga = { version = "0.14", features = ["glsl-in", "wgsl-out", "spv-out", "validate"] }

# WASM generation
wasm-encoder = "0.39"
wasmparser = "0.121"
walrus = "0.20"

# DWARF debug info
gimli = { version = "0.28", features = ["write"] }
object = "0.32"

# Utilities
thiserror = "1.0"
anyhow = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"

# Code generation
tera = "1.19"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# CLI
clap = { version = "4.4", features = ["derive", "cargo"] }
```

---

## ğŸ”§ Core Crate: `naga-wasm-backend`

### **Purpose**
Translate Naga IR to WASM bytecode with embedded DWARF debug information.

### **`Cargo.toml`**

```toml
[package]
name = "naga-wasm-backend"
version.workspace = true
edition.workspace = true

[dependencies]
naga.workspace = true
wasm-encoder.workspace = true
gimli.workspace = true
thiserror.workspace = true
tracing.workspace = true

[dev-dependencies]
wasmparser.workspace = true
insta = "1.34"  # Snapshot testing for WASM output
```

### **Public API (`lib.rs`)**

```rust
use naga::{Module, valid::ModuleInfo};
use std::collections::HashMap;

/// Configuration for WASM generation
#[derive(Debug, Clone)]
pub struct WasmBackendConfig {
    /// Include DWARF debug information
    pub debug_info: bool,
    /// Optimize generated WASM
    pub optimize: bool,
    /// Target WASM features (SIMD, threads, etc.)
    pub features: WasmFeatures,
}

/// Output of WASM compilation
#[derive(Debug)]
pub struct WasmModule {
    /// WASM bytecode
    pub wasm_bytes: Vec<u8>,
    /// Separate DWARF debug data (optional)
    pub dwarf_bytes: Option<Vec<u8>>,
    /// Entry point function names
    pub entry_points: HashMap<String, u32>,
}

/// Main backend interface
pub struct WasmBackend {
    config: WasmBackendConfig,
}

impl WasmBackend {
    pub fn new(config: WasmBackendConfig) -> Self { /* ... */ }
    
    /// Compile a Naga module to WASM
    pub fn compile(
        &self,
        module: &Module,
        info: &ModuleInfo,
        source: &str,  // Original GLSL source for DWARF
    ) -> Result<WasmModule, BackendError> {
        // Implementation in backend.rs
    }
}

/// Error types
#[derive(Debug, thiserror::Error)]
pub enum BackendError {
    #[error("Unsupported Naga IR feature: {0}")]
    UnsupportedFeature(String),
    
    #[error("WASM encoding error: {0}")]
    WasmEncoding(String),
    
    #[error("DWARF generation error: {0}")]
    DwarfGeneration(String),
}
```

---

## ğŸ¨ WASM Code Generation Strategy

### **Type Mapping**

| GLSL Type | Naga Type | WASM Representation |
|-----------|-----------|---------------------|
| `float` | `Scalar::F32` | `f32` (WASM local) |
| `int` | `Scalar::I32` | `i32` (WASM local) |
| `bool` | `Scalar::BOOL` | `i32` (0 or 1) |
| `vec2` | `Vector { size: 2, kind: Float }` | 2Ã— `f32` locals |
| `vec3` | `Vector { size: 3, kind: Float }` | 3Ã— `f32` locals |
| `vec4` | `Vector { size: 4, kind: Float }` | 4Ã— `f32` locals |
| `mat4` | `Matrix { columns: 4, rows: 4 }` | 16Ã— `f32` locals or memory |
| `sampler2D` | `Image` | `i32` (texture ID, host-managed) |

### **Memory Layout**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WASM Linear Memory Layout            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x0000: Stack (local variables)      â”‚
â”‚ 0x1000: Uniforms (read-only)         â”‚
â”‚ 0x2000: Attributes (per-vertex)      â”‚
â”‚ 0x3000: Varyings (interpolated)      â”‚
â”‚ 0x4000: Framebuffer (write output)   â”‚
â”‚ 0x5000: Texture data (host-managed)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Function Signatures**

**Vertex Shader WASM Function:**
```wasm
(func $vertex_main 
  (param $attr_ptr i32)      ;; Pointer to attribute data
  (param $uniform_ptr i32)   ;; Pointer to uniform data
  (param $varying_ptr i32)   ;; Pointer to output varyings
  (result f32 f32 f32 f32)   ;; gl_Position (x, y, z, w)
  ;; ... WASM instructions ...
)
```

**Fragment Shader WASM Function:**
```wasm
(func $fragment_main
  (param $varying_ptr i32)   ;; Pointer to interpolated varyings
  (param $uniform_ptr i32)   ;; Pointer to uniform data
  (result f32 f32 f32 f32)   ;; gl_FragColor (r, g, b, a)
  ;; ... WASM instructions ...
)
```

### **Built-in Functions**

GLSL built-ins are implemented as either:
1. **Inline WASM** (simple math: `abs`, `min`, `max`)
2. **Helper Functions** (complex: `normalize`, `cross`)
3. **Host Imports** (texture sampling: `texture2D`, `textureCube`)

Example: `dot(vec3, vec3)` implementation:
```wasm
(func $dot_vec3 (param $a0 f32) (param $a1 f32) (param $a2 f32)
                (param $b0 f32) (param $b1 f32) (param $b2 f32)
                (result f32)
  local.get $a0
  local.get $b0
  f32.mul
  
  local.get $a1
  local.get $b1
  f32.mul
  f32.add
  
  local.get $a2
  local.get $b2
  f32.mul
  f32.add
)
```

---

## ğŸ› DWARF Debug Information

### **Goals**
1. Map every WASM instruction to original GLSL source line/column
2. Preserve variable names and types for inspection
3. Enable breakpoints in GLSL source within DevTools

### **DWARF Sections to Generate**

| Section | Purpose | Priority |
|---------|---------|----------|
| `.debug_line` | Line number mapping (WASM â†” GLSL) | **Critical** |
| `.debug_info` | Variable types and scopes | High |
| `.debug_abbrev` | Abbreviation codes for `.debug_info` | High |
| `.debug_str` | String table (names, filenames) | High |
| `.debug_ranges` | Valid ranges for variables | Medium |
| `.debug_frame` | Call frame information | Low |

### **DWARF Generation Flow**

```rust
// Pseudo-code for DWARF generation
pub struct DwarfGenerator {
    dwarf: gimli::write::Dwarf,
    line_program: gimli::write::LineProgram,
    unit: gimli::write::Unit,
}

impl DwarfGenerator {
    pub fn add_instruction_mapping(
        &mut self,
        wasm_offset: u32,
        source_line: u32,
        source_column: u32,
    ) {
        self.line_program.row()
            .address_offset = wasm_offset as u64;
        self.line_program.row().line = source_line;
        self.line_program.row().column = source_column;
        self.line_program.generate_row();
    }
    
    pub fn add_variable(
        &mut self,
        name: &str,
        glsl_type: &str,
        wasm_local_index: u32,
        scope_start: u32,
        scope_end: u32,
    ) {
        let var = self.unit.add(
            self.unit.root(),
            gimli::constants::DW_TAG_variable
        );
        var.set(gimli::constants::DW_AT_name, name);
        var.set(gimli::constants::DW_AT_type, self.resolve_type(glsl_type));
        var.set(gimli::constants::DW_AT_location, 
                self.encode_wasm_local(wasm_local_index));
        // ... scope information ...
    }
}
```

### **Span Tracking Through Compilation**

```rust
// Each IR node has source span
pub struct IrNode {
    pub instruction: WasmInstruction,
    pub source_span: Option<naga::Span>,  // From Naga IR
}

// During WASM generation
impl WasmBackend {
    fn emit_instruction(&mut self, instr: WasmInstruction, span: Option<naga::Span>) {
        let wasm_offset = self.code.len();
        self.code.push(instr);
        
        if let Some(span) = span {
            let (line, col) = self.source_map.get_location(span);
            self.dwarf.add_instruction_mapping(wasm_offset, line, col);
        }
    }
}
```

---

## ğŸƒ Emulator Runtime: `wasm-gl-emu`

### **Purpose**
Execute compiled WASM shaders in a software rasterizer, providing the runtime environment for debugging.

### **`Cargo.toml`**

```toml
[package]
name = "wasm-gl-emu"
version.workspace = true
edition.workspace = true

[dependencies]
wasmtime = "16.0"  # WASM runtime
naga-wasm-backend = { path = "../naga-wasm-backend" }
thiserror.workspace = true
tracing.workspace = true

[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = { version = "0.3", features = ["WebGl2RenderingContext", "HtmlCanvasElement"] }
```

### **Core Runtime API**

```rust
use wasmtime::*;

pub struct ShaderRuntime {
    engine: Engine,
    module: Module,
    store: Store<RuntimeState>,
}

pub struct RuntimeState {
    memory: Vec<u8>,
    textures: Vec<Texture>,
    uniforms: UniformBuffer,
}

impl ShaderRuntime {
    pub fn new(wasm_bytes: &[u8]) -> Result<Self> {
        let engine = Engine::default();
        let module = Module::new(&engine, wasm_bytes)?;
        let store = Store::new(&engine, RuntimeState::new());
        Ok(Self { engine, module, store })
    }
    
    /// Execute vertex shader for a single vertex
    pub fn run_vertex_shader(
        &mut self,
        attributes: &[f32],
    ) -> Result<VertexOutput> {
        let instance = Instance::new(&mut self.store, &self.module, &[])?;
        let func = instance.get_typed_func::<(i32, i32, i32), (f32, f32, f32, f32)>(
            &mut self.store, 
            "vertex_main"
        )?;
        
        // Write attributes to memory
        self.write_attributes(attributes);
        
        // Call WASM function
        let (x, y, z, w) = func.call(&mut self.store, (
            ATTR_PTR, 
            UNIFORM_PTR, 
            VARYING_PTR
        ))?;
        
        Ok(VertexOutput { position: [x, y, z, w], /* ... */ })
    }
    
    /// Execute fragment shader for a single pixel
    pub fn run_fragment_shader(
        &mut self,
        varyings: &[f32],
    ) -> Result<[f32; 4]> {
        // Similar to vertex shader execution
    }
}

/// Host function: texture sampling (imported by WASM)
fn texture2d_sample(
    mut caller: Caller<'_, RuntimeState>,
    texture_id: i32,
    u: f32,
    v: f32,
) -> (f32, f32, f32, f32) {
    let state = caller.data();
    let texture = &state.textures[texture_id as usize];
    let color = texture.sample_bilinear(u, v);
    (color[0], color[1], color[2], color[3])
}
```

---

## ğŸ“‹ Implementation Phases

### **Phase 0: Validation (Weeks 1-2)**

**Goal:** Prove DWARF debugging works end-to-end

**Tasks:**
- [ ] Set up Rust workspace structure
- [ ] Create minimal WASM backend that compiles `void main() { }`
- [ ] Generate DWARF `.debug_line` section with `gimli`
- [ ] Load WASM in Chrome DevTools
- [ ] Verify breakpoint can be set on GLSL source line
- [ ] **Go/No-Go Decision**

**Success Criteria:**
- Breakpoint in GLSL source pauses execution
- DevTools shows GLSL source, not WASM

### **Phase 1: Core Backend (Weeks 3-10)**

**Goal:** Support basic shaders without textures

**Week 3-4: Type System**
- [ ] Implement scalar type translation (f32, i32, bool)
- [ ] Implement vector types (vec2, vec3, vec4)
- [ ] Basic expressions (arithmetic, comparison)
- [ ] Test with simple fragment shader: `gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);`

**Week 5-6: Control Flow**
- [ ] If/else statements
- [ ] For loops
- [ ] While loops
- [ ] Early return
- [ ] Test with conditional shaders

**Week 7-8: Functions & Variables**
- [ ] Local variables
- [ ] Function calls
- [ ] Parameters and return values
- [ ] DWARF variable information
- [ ] Test variable inspection in debugger

**Week 9-10: Built-in Functions**
- [ ] Math functions (sin, cos, pow, etc.)
- [ ] Vector operations (dot, cross, normalize, length)
- [ ] Matrix operations (matrix multiply)
- [ ] Test with lighting shader

### **Phase 2: Advanced Features (Weeks 11-16)**

**Week 11-12: Uniforms & Attributes**
- [ ] Uniform variables (memory layout)
- [ ] Vertex attributes (input layout)
- [ ] Varyings (interpolation)
- [ ] Test with textured triangle

**Week 13-14: Texture Sampling**
- [ ] Implement texture2D as WASM import
- [ ] Bilinear filtering
- [ ] Mipmap support
- [ ] Test with textured quad example

**Week 15-16: Matrix Types**
- [ ] Matrix storage (16 locals vs memory)
- [ ] Matrix-vector multiplication
- [ ] Matrix-matrix multiplication
- [ ] Test with 3D transformation shader

### **Phase 3: Integration (Weeks 17-20)**

**Week 17-18: Software Rasterizer**
- [ ] Triangle rasterization
- [ ] Vertex processing pipeline
- [ ] Fragment processing pipeline
- [ ] Framebuffer output

**Week 19-20: Polish & Testing**
- [ ] Performance optimization (WASM SIMD)
- [ ] Conformance testing
- [ ] Documentation
- [ ] Example gallery

### **Phase 4: Block 2 - Codegen Tool (Weeks 21-28)**

*Unchanged from original plan - see main README*

---

## âœ… Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Debugging UX** | Set breakpoint in GLSL, inspect variables | Manual testing in Chrome DevTools |
| **Shader Coverage** | 80% of common GLSL features | Test suite pass rate |
| **DWARF Accuracy** | 100% line mappings correct | Automated span tests |
| **Performance** | <100ms for 1024Ã—1024 fragment shader | Benchmark suite |
| **Browser Support** | Chrome, Firefox, Safari (WebKit) | Manual compatibility testing |

---

## ğŸš¨ Risk Register

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| DWARF not fully supported in browsers | Medium | High | Validate in Phase 0; build fallback debug UI |
| Naga IR changes break backend | Low | Medium | Pin Naga version; upstream contributions |
| Performance too slow for real scenes | Medium | Medium | Accept debug-only use case; optimize hot paths |
| Complex shaders fail to compile | Medium | High | Incremental complexity; robust error messages |

---

## ğŸ“š Reference Materials

### **DWARF Specification**
- [DWARF 5 Standard](https://dwarfstd.org/dwarf5std.html)
- [gimli Rust crate docs](https://docs.rs/gimli/)
- [Chrome DevTools WASM debugging](https://developer.chrome.com/blog/wasm-debugging-2020/)

### **WASM Specification**
- [WebAssembly Core Specification](https://webassembly.github.io/spec/core/)
- [wasm-encoder docs](https://docs.rs/wasm-encoder/)

### **Naga Documentation**
- [Naga repository](https://github.com/gfx-rs/naga)
- [Naga IR documentation](https://docs.rs/naga/)
- [wgpu backend examples](https://github.com/gfx-rs/naga/tree/main/src/back)

### **Prior Art**
- **Emscripten:** C++ â†’ WASM with DWARF debugging
- **wasm-pack:** Rust â†’ WASM debug info generation
- **AssemblyScript:** TypeScript-like â†’ WASM with source maps

---

## ğŸ¯ Next Actions

1. **Create Phase 0 branch** and set up workspace
2. **Implement minimal WASM backend** (emit empty function)
3. **Add basic DWARF generation** (line table only)
4. **Test in Chrome DevTools** (validate debugging works)
5. **Review results** and decide whether to proceed with full implementation

**Estimated Phase 0 Duration:** 2 weeks  
**Go/No-Go Decision Point:** End of Phase 0

---

*This document will be updated as implementation progresses and new insights are gained.*
