# 10.1 Function Calls & ABI plan

Goal: introduce a deterministic FunctionABI pass that takes Naga function/type information and produces a decisive representation of how each parameter and result is passed (Flattened scalars vs Frame pointer). Use this ABI to generate caller prologue/epilogue, callee conventions, and tests that assert WAT output.

---

## Summary
- Add `FunctionABI` facility: deterministic classification for parameters/results into `Flattened` or `Frame` categories + frame layout when needed.
- Implement caller-allocated LIFO frame support (FRAME_SP_GLOBAL) and simple caller prologue/epilogue lowering sequences.
- Integrate `FunctionABI` into the WASM backend: signature creation, call lowering, returns, and validation.
- Add a focused WAT test-suite (snapshots + pattern asserts) to lock the ABI and detect regressions.

---

## Design: FunctionABI (concept)

### Core structures
- FunctionABI
  - params: Vec<ParameterABI>
  - result: Option<ResultABI>
  - uses_frame: bool
  - frame_size: u32
  - frame_alignment: u32

- ParameterABI (enum)
  - Flattened { valtypes: Vec<ValType>, byte_size: u32 }
  - Frame { offset: u32, size: u32, align: u32, copy_in: bool, copy_out: bool, semantic: In|Out|InOut }

- Deterministic member ordering + canonical layout helpers will be part of the facility (shared with codegen).

### Decision rules (deterministic)
- Parameters/results classification rules (high level):
  - Scalars: Flattened.
  - Vectors/Matrices: Flattened if `total_bytes <= MAX_FLATTEN_BYTES` and scalar widths supported; else Frame.
  - Structs: recursively flatten if all members flattenable and total_bytes <= threshold; else Frame.
  - Arrays: Flatten only if Constant(count) and element flattenable and total_bytes <= threshold; else Frame (reject dynamic/pending in signatures with clear diagnostics).
  - Pointer/Image/Sampler: Frame or handle (i32), with resource-specific rules.
- Configurable constants: `MAX_FLATTEN_BYTES` (default e.g. 16 or 32) and `MAX_PARAM_COUNT` (safety guard).
- Strict use of `type_size()` / `span` / `stride` and scalar width helpers — no `*4` fallbacks.

---

## Frame allocator & prologue/epilogue

### FRAME_SP_GLOBAL
- Add a new global `FRAME_SP_GLOBAL` (i32) in `output_layout.rs` or extend existing globals.
- Caller allocates a contiguous aligned frame using LIFO rules and passes `frame_base` (i32) to callee.

### Allocation sequence (caller)
1. old_sp = global.get(FRAME_SP_GLOBAL)
2. aligned = align_up(old_sp, frame_alignment)
3. global.set(FRAME_SP_GLOBAL, aligned + frame_size)
4. write copy_in data into memory at (aligned + param.offset)
5. pass `(aligned + param.offset)` as i32 argument for Frame params

### Post-call (caller)
1. If copy_out needed, copy fields from (aligned + offset) to caller storage
2. global.set(FRAME_SP_GLOBAL, old_sp)

### Notes
- Caller owns allocation/deallocation (simpler recursion and ownership semantics).
- Optionally add overflow checks (trap or descriptive error) during alloc.

---

## Lowering & Integration points

### New module
- `src/naga_wasm_backend/function_abi.rs` (new)
  - Implements `FunctionABI` generation, layout computation, deterministic flattening rules, and unit tests.

### Frame helpers
- `src/naga_wasm_backend/frame_allocator.rs` (new) or helper functions in `backend.rs`/`expressions.rs`.
  - `emit_alloc_frame(ctx, size, align) -> (old_sp_local, aligned_local)`
  - `emit_free_frame(ctx, old_sp_local)`

### Backend changes
- `src/naga_wasm_backend/backend.rs`
  - In `compile_function`: ask `FunctionABI` for function signature (replace current direct calls to `naga_to_wasm_types` for signatures of internal functions).
  - Use `FunctionABI` result to create WASM type indices (flattened ValTypes + i32 pointer params for Frame params in canonical order).
- `src/naga_wasm_backend/expressions.rs`
  - Call lowering: when lowering a `Call` expression, inspect callee `FunctionABI`: emit allocation (if needed), copy_in stores for Frame args, pass scalar params and pointer params in correct order, and restore after call (copy_out if required).
- `src/naga_wasm_backend/types.rs`
  - Add utilities to compute scalar width in bytes, component size, and canonical map for flattening.
- `src/naga_wasm_backend/output_layout.rs`
  - Define `FRAME_SP_GLOBAL` and any constants.

---

## Validation & diagnostics
- Reject or emit explicit errors for unsupported signature elements:
  - dynamic or pending arrays in signatures
  - attempted by-value passing of resource handles when disallowed
- Produce actionable diagnostics with type handles and suggestions.

---

## Tests & WAT snapshots (concrete)

Add tests under `test/abi` and WAT snapshots under `test/snapshots/webgl2` (or `test/snapshots/abi` as preferred):

1. `abi_entrypoint_prologue.test.js` / `snapshots/webgl2/entrypoint-prologue.wat`
   - Asserts entrypoint `(param i32 i32 i32 i32 i32 i32)` and presence of `f32.store`/`i32.store` writing to varyings on return.

2. `abi_flatten_small_pod.test.js` / `snapshots/webgl2/flatten-pod.wat`
   - Small struct/vec passed to internal function => flattened scalar params asserted in WAT.

3. `abi_frame_alloc_caller.test.js` / `snapshots/webgl2/frame-alloc.wat`
   - Large struct/array passed to internal function => assert global.get FRAME_SP_GLOBAL, alignment math, global.set, `call` with i32 pointer, and frame restore.

4. `abi_nested_call_frame_isolation.test.js`
   - Assert nested alloc/dealloc pairs and memory isolation (optionally via wasm_gl_emu execution test).

5. `abi_reject_dynamic_array_signature.test.js`
   - Ensure compilation error is produced and message is deterministic.

Test harness will use the existing JS helpers specified in `docs/1.9-wat-testing.md` (`getShaderWat`, `getShaderModule`) and snapshot exact WAT text or perform regex pattern checks for instruction sequences. Snapshots must be updated explicitly with PRs per docs.

---

## Incremental PR plan

1. ✅ PR 1 (Tests first): add tests (shaders + test harness + initial WAT snapshots that reflect current behavior). Small.
   - Completed: `test/snapshots/webgl2/abi_entrypoint.js`, `abi_flatten.js`, `abi_types.js` with inline WAT equality assertions.
   - 7 test cases covering entrypoint signatures, parameter/result flattening, void/bool/int handling.
   
2. ✅ PR 2 (FunctionABI module + unit tests): implement `function_abi.rs` with classifiers and layout routines. Medium.
   - Completed: `src/naga_wasm_backend/function_abi.rs` with:
     - `FunctionABI`, `ParameterABI`, `ResultABI` structures.
     - Deterministic type classification (Flattened vs Frame).
     - Layout computation with alignment and frame sizing.
     - 16 unit tests covering scalars, vectors, matrices, structs, arrays.
     - Handles all Naga type variants including error cases.
   - All existing tests pass (265 pass, 0 fail).
   
3. ✅ PR 3 (Frame allocator + FRAME_SP_GLOBAL): add allocator helpers and constants. Small.
   - Completed: `src/naga_wasm_backend/frame_allocator.rs` with:
     - `emit_alloc_frame()`: Allocates aligned frame on LIFO stack.
     - `emit_free_frame()`: Restores frame pointer after call.
     - `emit_frame_store()` / `emit_frame_load()`: Store/load values at frame offsets.
     - FRAME_SP_GLOBAL (global index 5) added to output_layout.rs.
     - Backend now creates 6 globals (added frame stack pointer).
     - Frame stack memory region: 0x80000-0x9FFFF (512KB base, 128KB size).
     - Stack initialized to FRAME_STACK_BASE in entrypoint prologue.
     - 4 unit tests covering allocation, alignment validation, and store/load operations.
   - All existing tests pass (265 pass, 0 fail).
   
4. PR 4 (Integration & lowering): wire `FunctionABI` into `backend.rs` and `expressions.rs` lowering, add prologue/epilogue emission. Medium to Large.
5. PR 5 (Polish & diagnostics): add final tests, edge-cases, documentation updates (`docs/10.1-calls.md`), and update WAT snapshots. Small.

Each PR should run tests and snapshot comparisons. Prefer small incremental merges to make reviews easy.

---

## Acceptance criteria
- All new tests pass and WAT snapshots are deterministic. Tests assert both functional correctness (frames restore, no corruption) and WAT patterns (allocation math, param ordering).
- `FunctionABI` has unit tests covering classification and layout for scalar/vector/matrix/array/struct cases.
- No runtime regressions for existing shader workloads (run existing test suite).

---

## Estimated effort (rough)
- `function_abi.rs` + tests: **medium**
- frame allocator + helpers: **small**
- wiring lowering + tests: **medium-large**
- tests & snapshots (PR 1): **small**

---

## Notes
- Keep the design modular: `FunctionABI` should be pure and tested independently from the lowering so we can iterate lowering strategies safely.
- Decide `MAX_FLATTEN_BYTES` and make it a module-level constant to tune performance/compatibility.
- ALWAYS build with `npm run build`, any other build via cargo is only partial and does not produce the correct binaries
- ALWAYS verify that all tests pass, do NOT leave some tests failing
---

If you confirm, I can implement the Tests‑first PR (create test shaders and WAT snapshot tests) so we have a failing test-suite to guide the lowering changes next.
