# Plan: Removal of JS Shader Trampoline ("Untrampoline")

## 1. Objective
Eliminate the JavaScript function `wasm_execute_shader` that acts as a middleware (trampoline) between the Rust Rasterizer and the compiled Shader WASM modules.

**Current Flow:**
`Rust (Rasterizer)` -> `JS (Trampoline)` -> `WASM (Shader)`

**Target Flow:**
`Rust (Rasterizer)` -> `WASM (Shader)`

## 2. Technical Analysis

### 2.1. The Direct Call Mechanism
Rust's `wasm32-unknown-unknown` target implements function pointers using the standard WASM `call_indirect` instruction. The `index.js` loader already links the main `webgl2.wasm` and the dynamic shader modules to the same `__indirect_function_table`.

Therefore, if Rust knows the **Table Index** of a shader, it can cast that integer to a `fn` pointer and call it. This generates a `call_indirect` instruction which the WASM runtime executes directly, bypassing the JS host entirely.

### 2.2 ABI Optimization (The "Turbo" calling convention)
To achieve raw machine execution speed, we eliminate per-call overhead by splitting shader data into three transmission tiers:

*   **Tier 1: Shared Imported Globals (The Environment)**
    Instead of passing pointers (uniforms, textures, attributes) as arguments, the Shader module **imports** these globals from the host environment (`env`).
    *   **Rust Side**: Exports 5-6 pointers (`ACTIVE_UNIFORM_PTR`, `ACTIVE_ATTR_PTR`, etc.) once per draw call.
    *   **Shader Side**: These are declared as `(import "env" "NAME" (global (mut i32)))`.
    *   **Effect**: The cost of "synchronizing" the shader's environment across millions of calls is reduced to **zero instructions** inside the `main` function.
*   **Tier 2: Register Arguments (The Volatile Loop)**
    Only variables that change with every iteration are passed as direct function parameters.
    *   **Vertex Shader**: `(vertex_id: i32, instance_id: i32, varying_out_ptr: i32)`.
    *   **Fragment Shader**: `(varying_in_ptr: i32, private_ptr: i32)`.
    *   **Effect**: JITs map these directly to CPU registers (e.g., `EAX`, `ECX`), avoiding stack/memory round-trips entirely.
*   **Tier 3: Multi-value Returns (The Output)**
    Common results (Clip-space Position for VS, Color for FS) are returned directly via the WASM stack as `(f32, f32, f32, f32)`.
    *   **Effect**: Eliminates the "Store in Shader" -> "Load in Rasterizer" synchronization cycle.

### 2.3. The Lifecycle Hazard ("Unload")
**Problem**: Currently, `webgl2_context.js` manages table allocation. When `deleteProgram` is called in JS, it **immediately** frees the table index in the `TableAllocator`.
*   **GL Spec Violation**: A program active in the context must kept alive (and executable) until unbound, even if deleted.
*   **Direct Call Danger**: If JS frees index `X`, and assigns it to a new Shader `Y`, but Rust still thinks the current program uses index `X`, the direct call will invoke Shader `Y` with Shader `X`'s state.

**Solution: Invert Ownership of Table Indices**
1.  **Disable JS Freeing**: Remove the `tableAllocator.free()` calls from `deleteProgram` in `webgl2_context.js`.
2.  **Rust-Driven Release**: The `Program` struct in Rust effectively "owns" the compiled shader slots.
3.  **New Import**: Add `fn js_free_shader_index(idx: u32)` to the Rust imports (`src/lib.rs`).
4.  **Drop Implementation**: When the `Program` struct in Rust is dropped (refcount reaches 0), it calls `js_free_shader_index`.
    *   This ensures the index remains valid exactly as long as the Rust `Rasterizer` might potentially call it.

## 3. Implementation Steps

### Step 1: Definition of Shared Segment
1.  **Rust Side**: In `src/lib.rs`, declare and export the `static mut` globals that represent the active shader environment (Uniforms, Attributes, Varying Base, Private Base, Texture Base).
2.  **Backend Side**: Update `src/naga_wasm_backend/output_layout.rs` to reflect the mapping to these shared globals.

### Step 2: Backend Codegen Refactor
1.  **Import Emission**: Modify `src/naga_wasm_backend/backend.rs` to emit `ImportSection` entries for the shared globals.
2.  **Signature Change**: Update the `main` entry point to use the optimized `Tier 2` signature.
3.  **Epilogue Update**: Change the result evaluation logic to return the `(f32, f32, f32, f32)` tuple.

### Step 3: JS Linker (Live-Linking)
1.  **Global Capture**: In `index.js`, update `wasm_register_shader` to retrieve the `Global` instances from the main Rust WASM module exports.
2.  **Instantiation**: Pass these `Global` references into the `env` object when instantiating the dynamic shader modules. This connects the "Ghost Globals" in the shader directly to the Rust registers.

### Step 4: High-Performance Rasterizer Integration
*   Modify `src/wasm_gl_emu/rasterizer.rs`:
    *   Update the `call_indirect` logic to use the new optimized signatures.
    *   Update the hot loops to set the `static mut` host globals once per draw call.
    *   Implement zero-copy varying pointer calculation (Tier 2).

## 4. Verification Plan
1.  **Build**: Full `npm run build`.
2.  **Test**: `npm test`.
3.  **Benchmark**: Verify performance improvement in `complexShader.test.js`.

## 4. Verification Plan
1.  **Build**: Full `npm run build`.
2.  **Test**: `npm test`.
3.  **Benchmark**: Verify performance improvement in `complexShader.test.js`.
