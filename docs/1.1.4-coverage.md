# 1.1.4 â€” Coverage Plan (WASM / Rust)

**Status:** Proposal / Implementation plan

## ðŸŽ¯ Goal
Provide a reliable, reproducible coverage workflow for Rust code compiled to `wasm32-unknown-unknown` that:
- Produces source-level coverage reports (LCOV / HTML) for test runs executed under Node.js or CI.
- Works on stable Rust toolchains (no nightly required for core instrumentation).
- Avoids brittle reliance on V8 inspector coverage for WASM (fallback available).

---

## ðŸ§­ Approach (recommended)
Use LLVM's source-based coverage (`-C instrument-coverage`) and provide a profiler runtime for WASM using `minicov`. Capture the in-memory counters from WASM linear memory and emit `.profraw` files that can be merged and analyzed with `llvm-profdata` + `llvm-cov` (which can read covmap metadata embedded in the `.wasm`).

Why: the previous V8/inspector approach sometimes does not expose WASM offsets. The `minicov` approach is explicit and stable-friendly.

---

## ðŸ“¦ Dependencies
Add to crate dev-dependencies (example in `Cargo.toml`):

```toml
[dev-dependencies]
minicov = "0.3"
wasm-bindgen-test = "0.3.42"  # if you use wasm-bindgen-test harness
```

Notes:
- Use the `minicov` feature that supplies the profiler runtime symbols (see minicov docs for exact feature flags, e.g. `provide-extern-functions`).
- `wasm-bindgen-test` helps run tests under Node and provides an easy JS gluepoint for saving coverage blobs.

---

## ðŸ§ª Minimal PoC (outline)
### Rust test (example)
Add a small test that captures the profiler data and hands it to JS:

```rust
// tests/coverage_capture.rs
#![cfg(target_arch = "wasm32")]
use wasm_bindgen::prelude::*;
use wasm_bindgen_test::*;

#[wasm_bindgen]
extern "C" {
    fn save_coverage_data(b64: &str);
}

#[wasm_bindgen_test]
fn smoke_and_capture() {
    // exercise some code
    assert_eq!(2 + 2, 4);

    // capture raw prof data into a Vec<u8>
    let mut buf = Vec::new();
    unsafe { minicov::capture_coverage(&mut buf).expect("capture failed"); }

    // base64-encode and call into the host to persist
    let b64 = base64::engine::general_purpose::STANDARD.encode(&buf);
    save_coverage_data(&b64);
}
```

### Node helper (save_coverage_data binding)
If using `wasm-bindgen` the test runner can provide `globalThis.save_coverage_data = (b64) => fs.writeFileSync('out.profraw', Buffer.from(b64, 'base64'))` before running tests.

### Build & run (developer commands)
```bash
# build tests with coverage instrumentation and debug info
export RUSTFLAGS='-C instrument-coverage -C debuginfo=2 -C codegen-units=1 -C opt-level=0'
export CARGO_INCREMENTAL=0
cargo test --target wasm32-unknown-unknown --no-run

# run wasm-bindgen-test-runner (or runner2 satellite that provisions save_coverage_data)
wasm-bindgen-test-runner target/wasm32-unknown-unknown/debug/deps/<your_test>.wasm --node
# or use runner2's satellite mechanism which injects save_coverage_data into the Node context
```

### Merge & report
```bash
# produce profdata
llvm-profdata merge -sparse out.profraw -o coverage.profdata

# create line-level report from the wasm binary
llvm-cov report --instr-profile=coverage.profdata target/wasm32-unknown-unknown/debug/deps/your_crate.wasm
# or show HTML: llvm-cov show --instr-profile=coverage.profdata ... > report.html
```

---

## âœ… Verification checklist (what to verify after a PoC)
- [ ] `wasm` contains coverage metadata sections (`__llvm_covmap`, `__llvm_prf_names`) â€” check via `wasm-objdump -x` or `llvm-readobj`.
- [ ] `out.profraw` is non-empty and was written by the test run.
- [ ] `llvm-profdata merge -sparse out.profraw` succeeds without error.
- [ ] `llvm-cov report` produces file:line entries rather than `unknown`.


---

## Alternatives & fallback
- **V8 Inspector + runner2**: still useful for runtime-level coverage and for JS integration tests; sometimes fails to expose WASM offsets (inconsistent across Node versions). Keep it as a parallel path.
- **Binary instrumentation or Emscripten-style approaches**: more invasive; prefer `minicov` if you want to remain on stable and minimize toolchain patches.

---

## Pitfalls & notes
- Ensure `minicov` provides the expected linker symbols for the target; if you see missing extern errors during linking, enable its runtime-providing feature (see minicov README).
- Keep debug info (`-C debuginfo=2`) to allow source mapping. Using `--release` profile usually strips debug info unless configured.
- Merge multiple `.profraw` files when tests run in parallel or across multiple binaries.
- `llvm-cov` and `llvm-profdata` versions must be compatible with the codegen used by Rust/LLVM on the host.

