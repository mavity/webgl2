# WASM GPU expansion

Based on a review of the naga_wasm_backend directory, here is an assessment of the current Naga IR implementation status.

The backend is currently in an **early "Phase 0" state**, focusing on basic arithmetic and the "Consistent f32 Stack" architecture required for the software rasterizer.

### 1. Type System (types.rs)
*   **Implemented**: Scalars (Float, Int, Uint, Bool), Vectors (vec2/3/4), and Matrices.
*   **Memory Layout**: Uses a fixed memory map where `GlobalVariables` are assigned offsets in specific address spaces (Uniform, Attribute, Varying, Private).
*   **Missing**: Dynamic arrays, Atomics, and complex resource types (Acceleration structures, Ray queries).

### 2. Expressions (expressions.rs)
*   **Implemented**:
    *   **Arithmetic**: `Add`, `Subtract`, `Multiply`, `Divide` (using bit-reinterpretation for integers). Matrix-Vector multiplication is implemented.
    *   **Logic**: `Equal`, `NotEqual` (partial).
    *   **Access**: `Load`, `Store`, `AccessIndex` (constant indices), `Swizzle`, `Splat`.
    *   **Conversions**: `As` (Float $\leftrightarrow$ Int $\leftrightarrow$ Bool).
    *   **Resources**: Basic 2D `ImageSample` (manually implemented via texel fetch logic in `expressions.rs`).
*   **Missing**:
    *   **Matrix Operations**: Matrix-Matrix multiplication and Matrix-Scalar operations are not fully implemented.
    *   **Math Built-ins**: `dot`, `cross`, `normalize`, `sin`, `cos`, `pow`, `clamp`, `min`, `max`, `abs`, `floor`, `ceil`, `fract`, etc. (These are currently entirely missing and `builtins.rs` is empty).
    *   **Dynamic Indexing**: `Access` with non-constant indices (requires runtime offset calculation).
    *   **Derivatives**: `dpdx`, `dpdy`, `fwidth` (critical for mipmapping and anti-aliasing).
    *   **Bitwise**: `And`, `Or`, `Xor`, `Shift`, `Not`.
    *   **Relational**: `Less`, `LessEqual`, `Greater`, `GreaterEqual`.

### 3. Control Flow (control_flow.rs)
*   **Implemented**: `Block`, `If`, `Return`, `Store`, and `Call` (with debug trampolining).
*   **Missing**:
    *   **Loops**: `Loop` and `While` are not implemented.
    *   **Branching**: `Switch`, `Break`, `Continue`.
    *   **Fragment Ops**: `Kill` (discard).
    *   **Structured Control Flow**: Mapping Naga's structured blocks to WASM's `loop`/`block`/`br` instructions.

### 4. Module & Infrastructure (backend.rs)
*   **Implemented**:
    *   **Function Mapping**: Internal functions and Entry Points.
    *   **Global Mapping**: Maps `GlobalVariable` handles to memory offsets.
    *   **Debug Support**: Integration with a JS `debug_step` import for shader stepping.
*   **Critical Gap**:
    *   **EntryPoint Arguments**: The backend currently ignores `EntryPoint` arguments (WGSL style) and relies on the Naga GLSL front-end's behavior of creating `GlobalVariable` proxies. This is why WebGPU (WGSL) is currently rendering black.

### Summary Assessment
The backend is sufficient for **simple linear shaders** (like the ones used in basic WebGL2 tests) but lacks the control flow (loops) and math library (built-ins) required for production-grade shaders or the Naga conformance suite. The "Consistent f32 Stack" is a unique architectural choice that simplifies interpolation but requires careful bit-management for integer operations.

## Future Work & Heavy Lifting

Expanding the Naga WASM backend to support full WebGL2/WebGPU functionality requires significant effort in several key areas:

### 1. Structured Control Flow (The "Loop" Problem)
Naga's IR uses structured blocks, but WASM's control flow is based on nested `block`, `loop`, and `if` constructs with label-based branching (`br`, `br_if`).
*   **The Problem**: The core difficulty lies in the fundamental mismatch between Naga's high-level structured IR and WASM's stack-based label system.
    *   **Label Indexing**: In WASM, a branch instruction (`br $n`) doesn't jump to a named label but to the $n$-th surrounding control structure. This requires the backend to maintain a compile-time stack of active control blocks to calculate the correct relative depth for every `break` or `continue`.
    *   **Loop Topology**: A Naga `Loop` consists of a `body` and a `continuing` block. To map this to WASM, one typically needs a nested structure: a `block` (for `break` targets) wrapping a `loop` (for `continue` targets). Any `break` in Naga must be translated to a `br` to the outer `block`, while a `continue` must be a `br` to the inner `loop`.
    *   **Switch Complexity**: Naga's `Switch` statements require mapping to WASM's `br_table` or nested `if/else` blocks, both of which further complicate the label stack management.
*   **Proposed Implementation**:
    *   **Library**: Use `wasm_encoder::Instruction` variants: `Block`, `Loop`, `End`, `Br`, and `BrIf`.
    *   **The Label Stack**: Add a `Vec<ControlFrame>` to `TranslationContext` to track the nesting of `Block`, `Loop`, and `If`.
    ```rust
    enum ControlFrame {
        BreakTarget,
        ContinueTarget,
        IfBody,
    }
    ```
    *   **The "Triple-Nest" Trick**: To correctly handle Naga's `continuing` block (which must run after a `continue` but before the next iteration), use this structure:
        1. `Instruction::Block` (Label 2: Target for `break`)
        2. `Instruction::Loop` (Label 1: Target for restarting the loop)
        3. `Instruction::Block` (Label 0: Target for `continue`)
        4. Translate `body` statements.
        5. `Instruction::End` (End of body block).
        6. Translate `continuing` statements.
        7. Translate `break_if` expression + `Instruction::BrIf(2)`.
        8. `Instruction::Br(1)` (Jump back to start of loop).
        9. `Instruction::End` (End of loop).
        10. `Instruction::End` (End of break block).
    *   **The Catch**: WASM labels are indexed from the *inside out*. When translating `Statement::Break`, you must iterate backwards through the `ControlFrame` stack to find the correct relative index of the nearest `BreakTarget`.
*   **Heavy Lifting**: Implementing a robust `translate_statement` that can handle nested loops, `break`, and `continue` by maintaining a stack of WASM labels and ensuring that the `continuing` block of a Naga loop is correctly executed before jumping back to the start of the WASM `loop`.

### 2. Comprehensive Math Library (builtins.rs)
Currently, `builtins.rs` is a placeholder. Every GLSL/WGSL built-in must be implemented as a sequence of WASM instructions.
*   **Challenge**: Functions like `sin`, `cos`, `exp`, `log`, and `pow` are not native to WASM (which only has basic arithmetic).
*   **Heavy Lifting**: 
    *   Implementing polynomial approximations (e.g., Taylor series or minimax approximations) for transcendental functions.
    *   Implementing vector math operations (`dot`, `cross`, `reflect`, `refract`) which must be unrolled into scalar WASM instructions since we are not yet using WASM SIMD.

### 3. Dynamic Memory Access
The current implementation only supports `AccessIndex` with constant indices.
*   **Challenge**: `Access` with a dynamic index (e.g., `my_array[i]`) requires calculating the memory address at runtime: `base_addr + index * element_size`.
*   **Heavy Lifting**: Updating `expressions.rs` to handle `Expression::Access` by emitting instructions to calculate the effective address before performing a `Load` or `Store`.

### 4. Robust Resource Sampling
The current `ImageSample` implementation is a hardcoded 2D texel fetch.
*   **Challenge**: Real-world shaders require support for:
    *   **Sampler States**: Wrap modes (Repeat, ClampToEdge), Filtering (Linear, Nearest).
    *   **Mipmapping**: Calculating the correct LOD based on derivatives (`dpdx`, `dpdy`).
    *   **Texture Types**: 3D textures, Cube maps, Array textures, Shadow samplers.
*   **Heavy Lifting**: Moving sampling logic into a dedicated helper or a set of WASM functions that can be called from the shader, handling the complexity of coordinate normalization and filtering.

### 5. EntryPoint Argument Mapping
The backend currently relies on global variable proxies created by the Naga GLSL front-end.
*   **Challenge**: WebGPU (WGSL) uses explicit entry point arguments. The backend must map these arguments to the correct memory offsets in the `Uniform`, `Attribute`, or `Varying` buffers.
*   **Heavy Lifting**: Refactoring `compile_entry_point` in `backend.rs` to analyze `EntryPoint` arguments and bind them to the memory layout, ensuring compatibility with both GLSL and WGSL front-ends.

### 6. Integer and Boolean Correctness
The "Consistent f32 Stack" architecture stores everything as `f32` bits.
*   **Challenge**: Integer operations (`I32Add`, `I32Shl`, etc.) require constant reinterpretation (`F32ReinterpretI32` and `I32ReinterpretF32`).
*   **Heavy Lifting**: Ensuring that all bitwise and integer operations correctly mask and sign-extend values, especially when dealing with `u32` vs `i32` and boolean logic.