## Plan: Registry-Based Backend with Stack-First Function Calls

This plan refactors the WASM backend into a clean two-pass architecture (Preparation and Emission), eliminates all scratch locals, and implements sophisticated ABI handling with proper InOut semantics.

---

## Architecture Overview

**Current Problem**: The backend uses a fixed block of 64 scratch locals (32 i32 + 32 f32) allocated per function, causing:
- Fragile heuristic allocation
- Implicit offset semantics (which local does `+1` refer to?)
- Inability to optimize small/large value handling independently
- Missing InOut semantics for small types

**Solution**: Two-pass architecture where:
1. **Preparation Pass**: Analyzes Naga module once, computes `FunctionManifest` (ABI, frame size) for each function/entry-point
2. **Emission Pass**: Generates WASM using manifest data, uses pure WASM stack for all temporaries

---

## Phase 1: Create Registry Infrastructure (Pure Addition, No Behavior Change)

**Goal**: Add preparation pass and registry without modifying existing lowering.

**Files to create**:
- `src/naga_wasm_backend/functions/mod.rs` — Module definition
- `src/naga_wasm_backend/functions/registry.rs` — `FunctionRegistry` and `FunctionManifest` structs
- `src/naga_wasm_backend/functions/prep.rs` — `prep_module()` implementation

**Changes**:
1. In `registry.rs`, define:
   ```rust
   pub struct FunctionManifest {
       pub abi: FunctionABI,
       pub linear_frame_size: u32,  // Bytes needed on FRAME_SP stack
       pub needs_frame_alloc: bool,
   }
   
   pub struct FunctionRegistry {
       manifests: HashMap<Handle<Function>, FunctionManifest>,
       entry_manifests: HashMap<String, FunctionManifest>,
   }
   ```

2. In `prep.rs`, implement `pub fn prep_module(module: &Module, module_info: &ModuleInfo) -> FunctionRegistry`:
   - Iterate all functions: call `FunctionABI::compute()`, calculate frame size using existing logic
   - Populate manifests map
   - Entry points: use fixed ABI (6 pointer params), compute frame size for their locals

3. Update `src/naga_wasm_backend/mod.rs` to include the new submodule

4. Add unit tests verifying `prep_module()` correctly computes ABI and frame sizes

**Validation**:
- Run `cargo test --lib` — new tests pass
- Run `npm test` — all 265 tests pass (behavior unchanged)
- **State**: ✅ GREEN

---

## Phase 2: Enhance ABI with InOut Returns (Logic Only, No Behavior Change)

**Goal**: Update ABI calculation to handle small InOut parameters correctly by transforming them into additional return values.

**Changes in `src/naga_wasm_backend/function_abi.rs`**:

1. Add field to `FunctionABI`:
   ```rust
   pub implicit_returns: Vec<(Handle<FunctionArgument>, ComponentLayout)>,
   ```

2. Update `FunctionABI::compute()` parameter loop:
   - When processing InOut parameter ≤16 bytes:
     - Add to `parameters` as Flattened with `semantic: ParamSemantic::In`
     - Add to `implicit_returns`
     - Append components to result layout
   - When processing InOut parameter >16 bytes:
     - Keep as Frame with `copy_in: true, copy_out: true`

3. Add unit tests:
   - `test_inout_small_becomes_return()` — verify InOut i32 becomes input param + extra return
   - `test_inout_large_stays_frame()` — verify InOut large struct uses Frame

**Validation**:
- Run `cargo test --lib function_abi` — tests pass
- Run `npm test` — all 265 tests pass (new fields unused)
- **State**: ✅ GREEN

---

## Phase 3: Emit a Shader-Local Texture Sampling Primitive (and remove host impl)

**Goal**: Implement texture sampling as a primitive emitted directly into shader WASM modules (not as a Rust host export). The primitive must be emitted only when a shader actually uses sampling, carry an appropriate symbolic name, return 4 × f32 as *multivalue* (no pointers), and fully remove the previous Rust `texture_sample` implementation from the codebase.

**Scope (Initial)**
- Replace the Rust-host `texture_sample` path with a shader-local helper: `__webgl_texture_sample`
- Ensure the runtime places texture descriptors and texel data into WASM linear memory; sampling must be performed entirely in emitted WASM helpers (no host texel-fetch imports)
- Ensure the old Rust implementation is deleted, salted, and prevented from returning

**Why this approach**
- Guarantees shader-facing semantics are pure multivalue (no pointer passing or sret)
- Keeps sampling math and memory reads inside WASM where compiler can optimize it and ensures deterministic shader behavior
- Removes any requirement for a host texel-fetch import; the runtime is responsible for placing texture data and descriptors into WASM memory

**Concrete changes**

1) Remove the Rust host implementation entirely
- Delete the previous Rust `texture_sample` function and any helper structs (`F32x4`, wrapper functions) from `src/lib.rs`.
- **Do not remove existing JS helper/fallback exports (e.g., `__texture_texel_fetch`) from `src/webgl2_context.js` yet; retain them for compatibility.** The runtime should keep these functions available for now while the in-WASM helper is rolled out.
- Add a regression test that asserts the main module's exports do *not* contain Rust-based `texture_sample` to prevent accidental resurrection ("salt" test).

2) Emit a shader-local primitive named `__webgl_texture_sample`
- Emitted only when a shader uses image sampling.
- Signature (WASM-level): `(texture_ptr: i32, unit: i32, u: f32, v: f32) -> (f32, f32, f32, f32)` — returns 4 × f32 as multivalue; `texture_ptr` points to the descriptor table base in WASM memory.
- Implementation inside emitted WASM:
  - Decode/lookup the texture descriptor (unit → width/height/format/ptr) using module-provided descriptor table (or uniforms) as appropriate
  - Convert normalized UV to integer texel coordinates (apply wrap/clamp policy)
  - Use nearest filtering initially (minimal implementation), computing integer X/Y
  - Read texel bytes directly from WASM linear memory using the descriptor's `data_ptr`; load RGBA components with `I32Load8U`, convert to normalized f32 (byte / 255.0) and return them as `(f32,f32,f32,f32)` multivalue
  - No host import shall be used for texel fetching

3) Update lowering/emission in the backend
- In `src/naga_wasm_backend/backend.rs` and the emitter path, detect when `ImageSample` (or equivalent) is used and ensure the module emits `__webgl_texture_sample` and references it.
- **The in-WASM helper must use the same ABI as the previous host import** (`(texture_ptr: i32, unit: i32, u: f32, v: f32) -> (f32,f32,f32,f32)`), so shader lowering only needs to swap the call target and no other shader code changes are required.
- Lower `ImageSample` expressions to a call of `__webgl_texture_sample` and then pick components from the returned multivalue result (store into locals or directly use via stack/local get).
- Do not emit any pointer-based frame argument for sampling results — rely on true multivalue returns.

4) Runtime responsibilities
- The runtime must write texture descriptors (width, height, data_ptr, etc.) and texel data into WASM linear memory at the expected descriptor stride (32 bytes) before shader execution.
- Ensure memory bounds and lifetimes for any `Vec<u8>` backing texel data are maintained so WASM reads are valid during sampling.
- **Retain existing JS helper/fallback functions for now (do not remove them);** the runtime should keep these helpers available for compatibility while the in-WASM helper is adopted. Compiled shader modules **must not** import or call host texel-fetch functions; add a regression test that asserts the compiled module does NOT import any texel-fetch host function while the runtime continues to provide the JS helpers.

5) Tests and validation
- Add unit tests and snapshots that assert:
  - Shader modules using sampling instantiate without LinkError (no `texture_sample` import expected anymore)
  - The generated module text/types include a function named `__webgl_texture_sample` with function type `(i32,i32,f32,f32) -> (f32,f32,f32,f32)` (multivalue results)
  - A functional integration test: instantiate a shader that samples from a 2×2 test texture with known texel values and assert the sampled RGBA equals expected values (nearest sampling)
  - A "salt" regression test: the host exports must not include `texture_sample` (failing the test should block reintroduction)

6) Backwards compatibility / fallbacks
- Modern JS engines support multivalue imports/exports. If a runtime environment lacks native multivalue import support, provide an adapter in the JS layer that bridges to a memory-based sret-style call and returns the multivalue to WASM; this adapter lives in JS and not in Rust, so the Rust codebase remains free of sret-style exported sampling functions.

**Validation & Success Criteria**
- `npm run build` produces the updated WASM modules without errors
- `npm test` — all tests (including new sampling tests) pass
- No trace of the Rust `texture_sample` remains in `src/lib.rs`; the "salt" test fails if the Rust export is reintroduced. Existing JS helper exports may remain for compatibility during the rollout.
- Emitted shader WASM contains `__webgl_texture_sample` only when sampling is used, and its function type returns four `f32` values (multivalue), with no pointer-based results

**Notes & Future Work**
- Start with nearest-neighbor sampling in WASM; extend to bilinear, mipmap, and wrap modes incrementally.
- No texel-fetch host import is used; platform-dependent code must ensure texture data is available in WASM memory.
- This design keeps the shader-facing ABI clean and multivalue-first while avoiding pointer/persistent memory contracts in Rust.

**State**: Ready to implement (if you approve, I will remove the Rust-side sampling import, add emission of `__webgl_texture_sample` that reads texels from WASM memory, update the runtime to populate descriptors and texel data, and add the tests described above).

---

## Phase 4: Eliminate Remaining Scratch Locals (Store Operations Only)

**Goal**: Remove remaining `scratch_base` references (store operations), rewrite to use stack or inline locals.

**Note**: Texture sampling scratch usage already eliminated by Phase 3.

**Changes in `src/naga_wasm_backend/control_flow.rs`**:

1. **Remove `scratch_f32_base` usage in store operations**
   - Current code uses `scratch_base` (i32 temp) and `scratch_base + 32` (f32 temp) in `store_components_to_memory()`
   - Replace with stack manipulation or single inline local allocation
   - Use `local.tee` for value duplication where needed

**Optional Changes in `src/naga_wasm_backend/call_lowering.rs`** (if scratch used):

2. **Verify frame-based call implementation**
   - Check if `emit_frame_based_call()` uses any scratch locals
   - If so, replace with inline local allocation for `old_sp` storage
   - Implement `emit_memory_copy()` helper if needed: unrolled i32.load/store for ≤64 bytes, loop for larger

3. **Verify no `scratch_base` references remain**
   - Grep the codebase: ensure zero occurrences outside the allocation site in `backend.rs`
   - Expected remaining: ~2 locals (1 i32, 1 f32 for stores) vs original 64

**Validation**:
- Run `cargo build` — compiles without errors
- Run `npm test` — all 265 tests pass (scratch block unused but still allocated)
- Grep `scratch_base` in lowering code: zero matches (except allocation)
- **State**: ✅ GREEN

---

## Phase 5: Wire Registry & Delete Scratch Allocation (Atomic Cleanup)

**Goal**: Connect registry into compilation flow and remove dead scratch allocation in one atomic step.

**Changes in `src/naga_wasm_backend/backend.rs`**:

1. In `WasmBackend::write()`, add before function compilation:
   ```rust
   let registry = functions::prep_module(&module, &module_info);
   ```

2. Update `compile_function()` signature:
   ```rust
   fn compile_function(
       &self,
       handle: Handle<Function>,
       registry: &FunctionRegistry,
       ...
   ) -> Result<...>
   ```

3. In `compile_function()`:
   - Replace fresh ABI computation with: `let manifest = registry.get_function(handle)?;`
   - Use `manifest.abi` instead of computing
   - **Delete** lines that allocate 64 scratch locals (32 i32 + 32 f32)
   - Remove `scratch_base` variable assignment

4. Update `TranslationContext` creation:
   - Remove `scratch_base` field from struct (in `mod.rs`)
   - Remove passing `scratch_base` to `TranslationContext::new()`

**Changes in `src/naga_wasm_backend/mod.rs`**:

5. Update `TranslationContext` struct:
   - Remove `pub scratch_base: u32`
   - Add `pub function_registry: &'a FunctionRegistry`

6. Update `TranslationContext::new()` to accept and store registry

**Validation**:
- Run `cargo build` — compiles without errors
- Run `npm test` — all 265 tests pass (scratch block deleted, all code uses stack)
- **State**: ✅ GREEN

---

## Phase 6: Testing & Validation

**Goal**: Comprehensive verification of correctness.

**Tests to add**:

1. Unit tests in `src/naga_wasm_backend/functions/tests.rs`:
   - `test_prep_module_basic()` — registry computes basic function ABI
   - `test_frame_size_large_params()` — frame size calculated correctly for large structs
   - `test_inout_small_return()` — verify InOut small becomes implicit return

2. Snapshot tests in `test/snapshots/webgl2/`:
   - `abi_inout_scalar.js` — InOut i32 becomes input param + extra return value
   - `abi_inout_large.js` — InOut 80-byte struct uses Frame copy-in/copy-out
   - `abi_no_scratch.js` — Assert generated WASM has zero scratch-pattern locals

3. Run full validation:
   ```bash
   cargo test --lib
   npm run build
   npm test
   ```

**Validation**:
- Run `npm test` — all 270+ tests pass
- Grep WASM output: verify no scratch-offset patterns
- Manual inspection: verify copy_in/copy_out sequences where expected
- **State**: ✅ GREEN

---

## Summary: Six Clean Phases

| Phase | Files | Goal | Status |
| :--- | :--- | :--- | :--- |
| 1 | Create `functions/` module | Registry infrastructure | Pure addition, zero behavior change |
| 2 | Enhance `function_abi.rs` | InOut semantics | Logic only, unused fields |
| 3 | Add `lib.rs`, wire `backend.rs`, `expressions.rs` | Import runtime builtins (texture sampling) | Eliminate texture scratch locals |
| 4 | Rewrite `expressions.rs`, `call_lowering.rs`, `control_flow.rs` | Eliminate remaining scratch usage | Stack-first, keep allocation slot |
| 5 | Wire in `backend.rs`, `mod.rs` | Delete scratch block | Atomic integration |
| 6 | Add tests | Validation | Comprehensive coverage |

Each phase leaves the codebase **compilable, testable, and green**. No "partial refactor" states.

---

## Key Design Decisions

**1. Small (≤16 bytes) Return Values**
- Use WASM multi-value returns
- For InOut params: transform into input param + additional return value
- Avoids memory load/store overhead

**2. Large (>16 bytes) Return Values**
- Use Linear Stack (Return Slot Optimization pattern)
- Caller passes a pointer; callee writes result

**3. Frame Alignment**
- Always 16-byte alignment (global constant, not per-function)
- Simplifies logic, matches `vec4` alignment

**4. Entry Points**
- Special handling: fixed 6-pointer signature, global initialization
- Use same registry infrastructure as regular functions
- Separate `prep_entry_point()` path

**5. Call Semantics**
- Treat all unknown calls as potentially memory-touching
- Implement copy_in/copy_out conservatively
- Future optimization: opt-in `pure` annotation if needed

---

## Testing Strategy

- **Unit**: ABI computation, frame sizing, InOut transformation
- **Integration**: Large structs, arrays, mixed params, InOut semantics
- **Regression**: Full suite (265 tests unchanged)
- **Manual**: WAT inspection for copy sequences, frame allocation patterns

