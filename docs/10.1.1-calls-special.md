## Plan: Registry-Based Backend with Stack-First Function Calls

This plan refactors the WASM backend into a clean two-pass architecture (Preparation and Emission), eliminates all scratch locals, and implements sophisticated ABI handling with proper InOut semantics.

---

## Architecture Overview

**Current Problem**: The backend uses a fixed block of 64 scratch locals (32 i32 + 32 f32) allocated per function, causing:
- Fragile heuristic allocation
- Implicit offset semantics (which local does `+1` refer to?)
- Inability to optimize small/large value handling independently
- Missing InOut semantics for small types

**Solution**: Two-pass architecture where:
1. **Preparation Pass**: Analyzes Naga module once, computes `FunctionManifest` (ABI, frame size) for each function/entry-point
2. **Emission Pass**: Generates WASM using manifest data, uses pure WASM stack for all temporaries

---

## Phase 1: Create Registry Infrastructure (Pure Addition, No Behavior Change)

**Goal**: Add preparation pass and registry without modifying existing lowering.

**Files to create**:
- `src/naga_wasm_backend/functions/mod.rs` — Module definition
- `src/naga_wasm_backend/functions/registry.rs` — `FunctionRegistry` and `FunctionManifest` structs
- `src/naga_wasm_backend/functions/prep.rs` — `prep_module()` implementation

**Changes**:
1. In `registry.rs`, define:
   ```rust
   pub struct FunctionManifest {
       pub abi: FunctionABI,
       pub linear_frame_size: u32,  // Bytes needed on FRAME_SP stack
       pub needs_frame_alloc: bool,
   }
   
   pub struct FunctionRegistry {
       manifests: HashMap<Handle<Function>, FunctionManifest>,
       entry_manifests: HashMap<String, FunctionManifest>,
   }
   ```

2. In `prep.rs`, implement `pub fn prep_module(module: &Module, module_info: &ModuleInfo) -> FunctionRegistry`:
   - Iterate all functions: call `FunctionABI::compute()`, calculate frame size using existing logic
   - Populate manifests map
   - Entry points: use fixed ABI (6 pointer params), compute frame size for their locals

3. Update `src/naga_wasm_backend/mod.rs` to include the new submodule

4. Add unit tests verifying `prep_module()` correctly computes ABI and frame sizes

**Validation**:
- Run `cargo test --lib` — new tests pass
- Run `npm test` — all 265 tests pass (behavior unchanged)
- **State**: ✅ GREEN

---

## Phase 2: Enhance ABI with InOut Returns (Logic Only, No Behavior Change)

**Goal**: Update ABI calculation to handle small InOut parameters correctly by transforming them into additional return values.

**Changes in `src/naga_wasm_backend/function_abi.rs`**:

1. Add field to `FunctionABI`:
   ```rust
   pub implicit_returns: Vec<(Handle<FunctionArgument>, ComponentLayout)>,
   ```

2. Update `FunctionABI::compute()` parameter loop:
   - When processing InOut parameter ≤16 bytes:
     - Add to `parameters` as Flattened with `semantic: ParamSemantic::In`
     - Add to `implicit_returns`
     - Append components to result layout
   - When processing InOut parameter >16 bytes:
     - Keep as Frame with `copy_in: true, copy_out: true`

3. Add unit tests:
   - `test_inout_small_becomes_return()` — verify InOut i32 becomes input param + extra return
   - `test_inout_large_stays_frame()` — verify InOut large struct uses Frame

**Validation**:
- Run `cargo test --lib function_abi` — tests pass
- Run `npm test` — all 265 tests pass (new fields unused)
- **State**: ✅ GREEN

---

## Phase 3: Emit a Shader-Local Texture Sampling Primitive (and remove host impl)

**Goal**: Implement texture sampling as a primitive emitted directly into shader WASM modules (not as a Rust host export). The primitive must be emitted only when a shader actually uses sampling, carry an appropriate symbolic name, return 4 × f32 as *multivalue* (no pointers), and fully remove the previous Rust `texture_sample` implementation from the codebase.

**Scope (Initial)**
- Replace the Rust-host `texture_sample` path with a shader-local helper: `__webgl_texture_sample`
- Ensure the runtime places texture descriptors and texel data into WASM linear memory; sampling must be performed entirely in emitted WASM helpers (no host texel-fetch imports)
- Ensure the old Rust implementation is deleted, salted, and prevented from returning

**Why this approach**
- Guarantees shader-facing semantics are pure multivalue (no pointer passing or sret)
- Keeps sampling math and memory reads inside WASM where compiler can optimize it and ensures deterministic shader behavior
- Removes any requirement for a host texel-fetch import; the runtime is responsible for placing texture data and descriptors into WASM memory

**Concrete changes**

1) Remove the Rust host implementation entirely
- Delete the previous Rust `texture_sample` function and any helper structs (`F32x4`, wrapper functions) from `src/lib.rs`.
- **Do not remove existing JS helper/fallback exports (e.g., `__texture_texel_fetch`) from `src/webgl2_context.js` yet; retain them for compatibility.** The runtime should keep these functions available for now while the in-WASM helper is rolled out.
- Add a regression test that asserts the main module's exports do *not* contain Rust-based `texture_sample` to prevent accidental resurrection ("salt" test).

2) Emit a shader-local primitive named `__webgl_texture_sample`
- Emitted only when a shader uses image sampling.
- Signature (WASM-level): `(texture_ptr: i32, unit: i32, u: f32, v: f32) -> (f32, f32, f32, f32)` — returns 4 × f32 as multivalue; `texture_ptr` points to the descriptor table base in WASM memory.
- Implementation inside emitted WASM:
  - Decode/lookup the texture descriptor (unit → width/height/format/ptr) using module-provided descriptor table (or uniforms) as appropriate
  - Convert normalized UV to integer texel coordinates (apply wrap/clamp policy)
  - Use nearest filtering initially (minimal implementation), computing integer X/Y
  - Read texel bytes directly from WASM linear memory using the descriptor's `data_ptr`; load RGBA components with `I32Load8U`, convert to normalized f32 (byte / 255.0) and return them as `(f32,f32,f32,f32)` multivalue
  - No host import shall be used for texel fetching

3) Update lowering/emission in the backend
- In `src/naga_wasm_backend/backend.rs` and the emitter path, detect when `ImageSample` (or equivalent) is used and ensure the module emits `__webgl_texture_sample` and references it.
- **The in-WASM helper must use the same ABI as the previous host import** (`(texture_ptr: i32, unit: i32, u: f32, v: f32) -> (f32,f32,f32,f32)`), so shader lowering only needs to swap the call target and no other shader code changes are required.
- Lower `ImageSample` expressions to a call of `__webgl_texture_sample` and then pick components from the returned multivalue result (store into locals or directly use via stack/local get).
- Do not emit any pointer-based frame argument for sampling results — rely on true multivalue returns.

4) Runtime responsibilities
- The runtime must write texture descriptors (width, height, data_ptr, etc.) and texel data into WASM linear memory at the expected descriptor stride (32 bytes) before shader execution.
- Ensure memory bounds and lifetimes for any `Vec<u8>` backing texel data are maintained so WASM reads are valid during sampling.
- **Retain existing JS helper/fallback functions for now (do not remove them);** the runtime should keep these helpers available for compatibility while the in-WASM helper is adopted. Compiled shader modules **must not** import or call host texel-fetch functions; add a regression test that asserts the compiled module does NOT import any texel-fetch host function while the runtime continues to provide the JS helpers.

5) Tests and validation
- Add unit tests and snapshots that assert:
  - Shader modules using sampling instantiate without LinkError (no `texture_sample` import expected anymore)
  - The generated module text/types include a function named `__webgl_texture_sample` with function type `(i32,i32,f32,f32) -> (f32,f32,f32,f32)` (multivalue results)
  - A functional integration test: instantiate a shader that samples from a 2×2 test texture with known texel values and assert the sampled RGBA equals expected values (nearest sampling)
  - A "salt" regression test: the host exports must not include `texture_sample` (failing the test should block reintroduction)

6) Backwards compatibility / fallbacks
- Modern JS engines support multivalue imports/exports. If a runtime environment lacks native multivalue import support, provide an adapter in the JS layer that bridges to a memory-based sret-style call and returns the multivalue to WASM; this adapter lives in JS and not in Rust, so the Rust codebase remains free of sret-style exported sampling functions.

**Validation & Success Criteria**
- `npm run build` produces the updated WASM modules without errors
- `npm test` — all tests (including new sampling tests) pass
- No trace of the Rust `texture_sample` remains in `src/lib.rs`; the "salt" test fails if the Rust export is reintroduced. Existing JS helper exports may remain for compatibility during the rollout.
- Emitted shader WASM contains `__webgl_texture_sample` only when sampling is used, and its function type returns four `f32` values (multivalue), with no pointer-based results

**Notes & Future Work**
- Start with nearest-neighbor sampling in WASM; extend to bilinear, mipmap, and wrap modes incrementally.
- No texel-fetch host import is used; platform-dependent code must ensure texture data is available in WASM memory.
- This design keeps the shader-facing ABI clean and multivalue-first while avoiding pointer/persistent memory contracts in Rust.

**State**: Ready to implement (if you approve, I will remove the Rust-side sampling import, add emission of `__webgl_texture_sample` that reads texels from WASM memory, update the runtime to populate descriptors and texel data, and add the tests described above).

---

## Phase 4: Eliminate Remaining Scratch Locals (Store Operations Only)

**Goal**: Remove the last uses of the global *scratch block* and replace them with precise, named temps and stack-first code paths — performed in fully incremental steps that keep the repository green after each step.

**Overview**
- We identified three concrete uses of the scratch block: 1) frame-based call allocation, 2) store helper swap temps, and 3) texture sampling result temporaries.
- We will replace each with explicit, minimal locals or stack sequences in independent commits. Each commit will be build/test green and backed by a targeted regression assertion.

---

### Step 1 — Inline Frame Allocation (small, reversible)

**Files**: `src/naga_wasm_backend/call_lowering.rs`

**Change**:
- Replace the two-scratch-local allocation (`old_sp_local`, `aligned_local`) with an inline sequence that computes `aligned_base = align_up(global.get(FRAME_SP), align)`, sets `FRAME_SP = aligned_base + size`, and later restores `FRAME_SP` by subtracting `size` in the epilogue.
- If code needs to hold `aligned_base` across argument lowering, allocate a single `i32` temp local per function **only when** the function contains frame-based calls.

**Validation**:
- `npm run build` and `npm test` must pass
- Confirm removal of `old_sp_local`/`aligned_local` usage in `call_lowering.rs`

---

### Step 2 — Explicit Store Swap Locals

**Files**: `src/naga_wasm_backend/backend.rs`, `src/naga_wasm_backend/control_flow.rs`

**Change**:
- Allocate two explicit locals per function (conservatively or on-demand): `swap_i32_local` and `swap_f32_local`.
- Change `store_components_to_memory()` to use these named locals instead of scanning `local_types` for a scratch base.
- Pass the locals via `TranslationContext` so call sites are explicit and clear.

**Validation**:
- `npm run build` and `npm test` must pass
- `control_flow.rs` no longer scans `local_types` to find a scratch region

---

### Step 3 — Explicit Sampling Result Locals

**Files**: `src/naga_wasm_backend/backend.rs`, `src/naga_wasm_backend/expressions.rs`

**Change**:
- Reserve 4 `f32` locals per function that uses sampling (or allocate conservatively): `sample_locals: [u32; 4]`.
- Lower sampling multivalue results into these locals and read the requested component with an explicit `LocalGet`.

**Validation**:
- `npm run build` and `npm test` must pass (includes Phase 3 sampling tests)
- `expressions.rs` no longer references `ctx.scratch_base` for sampling

---

### Step 4 — Delete Scratch Block and Remove `scratch_base`

**Files**: `src/naga_wasm_backend/backend.rs`, `src/naga_wasm_backend/mod.rs`, tests

**Change**:
- Remove the 32×`f32` and 32×`i32` scratch locals from `compile_function()`.
- Delete `scratch_base` from `TranslationContext` and replace with named locals/fields (`swap_i32_local`, `swap_f32_local`, `sample_locals`, plus optional `frame_temp_local`).
- Update all call sites to the new context fields.

**Validation**:
- `npm run build` and `npm test` must pass
- Grep shows zero `scratch_base` occurrences in lowering code
- Inspect generated WASM to verify absence of large scratch local blocks

---

## Notes & Best Practices
- Land each step in its own commit/PR and run the full test suite before proceeding.
- It's acceptable to conservatively allocate a handful of named locals per function: clarity and correctness outweigh micro-optimizations.
- Where safe, prefer `local.tee` and stack-based sequences to avoid extra locals; use explicit locals where readability and determinism matter.
- Consider renaming `texture_texel_fetch_idx` → `webgl_texture_sample_idx` for clarity (Phase 3 cleanup).

**State**: ✅ Ready — four atomic, testable steps that keep the tree green after each change.


---

## Phase 5: Wire Registry & Delete Scratch Allocation (Atomic Cleanup)

**Goal**: Connect registry into compilation flow and remove dead scratch allocation in one atomic step.

**Changes in `src/naga_wasm_backend/backend.rs`**:

1. In `WasmBackend::write()`, add before function compilation:
   ```rust
   let registry = functions::prep_module(&module, &module_info);
   ```

2. Update `compile_function()` signature:
   ```rust
   fn compile_function(
       &self,
       handle: Handle<Function>,
       registry: &FunctionRegistry,
       ...
   ) -> Result<...>
   ```

3. In `compile_function()`:
   - Replace fresh ABI computation with: `let manifest = registry.get_function(handle)?;`
   - Use `manifest.abi` instead of computing
   - **Delete** lines that allocate 64 scratch locals (32 i32 + 32 f32)
   - Remove `scratch_base` variable assignment

4. Update `TranslationContext` creation:
   - Remove `scratch_base` field from struct (in `mod.rs`)
   - Remove passing `scratch_base` to `TranslationContext::new()`

**Changes in `src/naga_wasm_backend/mod.rs`**:

5. Update `TranslationContext` struct:
   - Remove `pub scratch_base: u32`
   - Add `pub function_registry: &'a FunctionRegistry`

6. Update `TranslationContext::new()` to accept and store registry

**Validation**:
- Run `cargo build` — compiles without errors
- Run `npm test` — all 265 tests pass (scratch block deleted, all code uses stack)
- **State**: ✅ GREEN

---

## Phase 6: Testing & Validation

**Goal**: Comprehensive verification of correctness.

**Tests to add**:

1. Unit tests in `src/naga_wasm_backend/functions/tests.rs`:
   - `test_prep_module_basic()` — registry computes basic function ABI
   - `test_frame_size_large_params()` — frame size calculated correctly for large structs
   - `test_inout_small_return()` — verify InOut small becomes implicit return

2. Snapshot tests in `test/snapshots/webgl2/`:
   - `abi_inout_scalar.js` — InOut i32 becomes input param + extra return value
   - `abi_inout_large.js` — InOut 80-byte struct uses Frame copy-in/copy-out
   - `abi_no_scratch.js` — Assert generated WASM has zero scratch-pattern locals

3. Run full validation:
   ```bash
   cargo test --lib
   npm run build
   npm test
   ```

**Validation**:
- Run `npm test` — all 270+ tests pass
- Grep WASM output: verify no scratch-offset patterns
- Manual inspection: verify copy_in/copy_out sequences where expected
- **State**: ✅ GREEN

---

## Summary: Six Clean Phases

| Phase | Files | Goal | Status |
| :--- | :--- | :--- | :--- |
| 1 | Create `functions/` module | Registry infrastructure | Pure addition, zero behavior change |
| 2 | Enhance `function_abi.rs` | InOut semantics | Logic only, unused fields |
| 3 | Add `lib.rs`, wire `backend.rs`, `expressions.rs` | Import runtime builtins (texture sampling) | Eliminate texture scratch locals |
| 4 | Rewrite `expressions.rs`, `call_lowering.rs`, `control_flow.rs` | Eliminate remaining scratch usage | Stack-first, keep allocation slot |
| 5 | Wire in `backend.rs`, `mod.rs` | Delete scratch block | Atomic integration |
| 6 | Add tests | Validation | Comprehensive coverage |

Each phase leaves the codebase **compilable, testable, and green**. No "partial refactor" states.

---

## Key Design Decisions

**1. Small (≤16 bytes) Return Values**
- Use WASM multi-value returns
- For InOut params: transform into input param + additional return value
- Avoids memory load/store overhead

**2. Large (>16 bytes) Return Values**
- Use Linear Stack (Return Slot Optimization pattern)
- Caller passes a pointer; callee writes result

**3. Frame Alignment**
- Always 16-byte alignment (global constant, not per-function)
- Simplifies logic, matches `vec4` alignment

**4. Entry Points**
- Special handling: fixed 6-pointer signature, global initialization
- Use same registry infrastructure as regular functions
- Separate `prep_entry_point()` path

**5. Call Semantics**
- Treat all unknown calls as potentially memory-touching
- Implement copy_in/copy_out conservatively
- Future optimization: opt-in `pure` annotation if needed

---

## Testing Strategy

- **Unit**: ABI computation, frame sizing, InOut transformation
- **Integration**: Large structs, arrays, mixed params, InOut semantics
- **Regression**: Full suite (265 tests unchanged)
- **Manual**: WAT inspection for copy sequences, frame allocation patterns

