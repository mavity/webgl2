## Plan: Registry-Based Backend with Stack-First Function Calls

This plan refactors the WASM backend into a clean two-pass architecture (Preparation and Emission), eliminates all scratch locals, and implements sophisticated ABI handling with proper InOut semantics.

---

## Architecture Overview

**Current Problem**: The backend uses a fixed block of 64 scratch locals (32 i32 + 32 f32) allocated per function, causing:
- Fragile heuristic allocation
- Implicit offset semantics (which local does `+1` refer to?)
- Inability to optimize small/large value handling independently
- Missing InOut semantics for small types

**Solution**: Two-pass architecture where:
1. **Preparation Pass**: Analyzes Naga module once, computes `FunctionManifest` (ABI, frame size) for each function/entry-point
2. **Emission Pass**: Generates WASM using manifest data, uses pure WASM stack for all temporaries

---

## Phase 1: Create Registry Infrastructure (Pure Addition, No Behavior Change)

**Goal**: Add preparation pass and registry without modifying existing lowering.

**Files to create**:
- `src/naga_wasm_backend/functions/mod.rs` — Module definition
- `src/naga_wasm_backend/functions/registry.rs` — `FunctionRegistry` and `FunctionManifest` structs
- `src/naga_wasm_backend/functions/prep.rs` — `prep_module()` implementation

**Changes**:
1. In `registry.rs`, define:
   ```rust
   pub struct FunctionManifest {
       pub abi: FunctionABI,
       pub linear_frame_size: u32,  // Bytes needed on FRAME_SP stack
       pub needs_frame_alloc: bool,
   }
   
   pub struct FunctionRegistry {
       manifests: HashMap<Handle<Function>, FunctionManifest>,
       entry_manifests: HashMap<String, FunctionManifest>,
   }
   ```

2. In `prep.rs`, implement `pub fn prep_module(module: &Module, module_info: &ModuleInfo) -> FunctionRegistry`:
   - Iterate all functions: call `FunctionABI::compute()`, calculate frame size using existing logic
   - Populate manifests map
   - Entry points: use fixed ABI (6 pointer params), compute frame size for their locals

3. Update `src/naga_wasm_backend/mod.rs` to include the new submodule

4. Add unit tests verifying `prep_module()` correctly computes ABI and frame sizes

**Validation**:
- Run `cargo test --lib` — new tests pass
- Run `npm test` — all 265 tests pass (behavior unchanged)
- **State**: ✅ GREEN

---

## Phase 2: Enhance ABI with InOut Returns (Logic Only, No Behavior Change)

**Goal**: Update ABI calculation to handle small InOut parameters correctly by transforming them into additional return values.

**Changes in `src/naga_wasm_backend/function_abi.rs`**:

1. Add field to `FunctionABI`:
   ```rust
   pub implicit_returns: Vec<(Handle<FunctionArgument>, ComponentLayout)>,
   ```

2. Update `FunctionABI::compute()` parameter loop:
   - When processing InOut parameter ≤16 bytes:
     - Add to `parameters` as Flattened with `semantic: ParamSemantic::In`
     - Add to `implicit_returns`
     - Append components to result layout
   - When processing InOut parameter >16 bytes:
     - Keep as Frame with `copy_in: true, copy_out: true`

3. Add unit tests:
   - `test_inout_small_becomes_return()` — verify InOut i32 becomes input param + extra return
   - `test_inout_large_stays_frame()` — verify InOut large struct uses Frame

**Validation**:
- Run `cargo test --lib function_abi` — tests pass
- Run `npm test` — all 265 tests pass (new fields unused)
- **State**: ✅ GREEN

---

## Phase 3: Eliminate Scratch Locals (Rewrite All Usage, Keep Allocation Slot)

**Goal**: Remove all references to `scratch_base`, rewrite all lowering to use WASM stack instead.

**Changes in `src/naga_wasm_backend/expressions.rs`**:

1. **Remove all `ctx.scratch_base` references**
   - Texture sampling (ImageSample): re-order calculation to keep `width`, `height`, `texel_x`, `texel_y` on stack
   - Use stack manipulation (e.g., `local.tee` for duplicates) to avoid storing intermediates

**Changes in `src/naga_wasm_backend/call_lowering.rs`**:

2. **Replace scratch local usage with inline allocation**
   - `emit_frame_based_call()`: allocate a single i32 local inline via `emit.local(ValType::I32)` for `old_sp` storage
   - Implement `emit_memory_copy()` helper: unrolled i32.load/store for ≤64 bytes, loop for larger
   - Implement copy_in: translate arg → compute frame offset → emit_memory_copy
   - Implement copy_out: compute frame offset → translate arg → emit_memory_copy
   - `emit_flattened_call()`: handle implicit returns from InOut params

**Changes in `src/naga_wasm_backend/control_flow.rs`**:

3. **Remove `scratch_f32_base` usage**
   - Use block-scoped locals or stack patterns for temporary storage

4. **Verify no `scratch_base` references remain**
   - Grep the codebase: ensure zero occurrences outside the allocation site in `backend.rs`

**Validation**:
- Run `cargo build` — compiles without errors
- Run `npm test` — all 265 tests pass (scratch block unused but still allocated)
- Grep `scratch_base` in lowering code: zero matches (except allocation)
- **State**: ✅ GREEN

---

## Phase 4: Wire Registry & Delete Scratch Allocation (Atomic Cleanup)

**Goal**: Connect registry into compilation flow and remove dead scratch allocation in one atomic step.

**Changes in `src/naga_wasm_backend/backend.rs`**:

1. In `WasmBackend::write()`, add before function compilation:
   ```rust
   let registry = functions::prep_module(&module, &module_info);
   ```

2. Update `compile_function()` signature:
   ```rust
   fn compile_function(
       &self,
       handle: Handle<Function>,
       registry: &FunctionRegistry,
       ...
   ) -> Result<...>
   ```

3. In `compile_function()`:
   - Replace fresh ABI computation with: `let manifest = registry.get_function(handle)?;`
   - Use `manifest.abi` instead of computing
   - **Delete** lines that allocate 64 scratch locals (32 i32 + 32 f32)
   - Remove `scratch_base` variable assignment

4. Update `TranslationContext` creation:
   - Remove `scratch_base` field from struct (in `mod.rs`)
   - Remove passing `scratch_base` to `TranslationContext::new()`

**Changes in `src/naga_wasm_backend/mod.rs`**:

5. Update `TranslationContext` struct:
   - Remove `pub scratch_base: u32`
   - Add `pub function_registry: &'a FunctionRegistry`

6. Update `TranslationContext::new()` to accept and store registry

**Validation**:
- Run `cargo build` — compiles without errors
- Run `npm test` — all 265 tests pass (scratch block deleted, all code uses stack)
- **State**: ✅ GREEN

---

## Phase 5: Testing & Validation

**Goal**: Comprehensive verification of correctness.

**Tests to add**:

1. Unit tests in `src/naga_wasm_backend/functions/tests.rs`:
   - `test_prep_module_basic()` — registry computes basic function ABI
   - `test_frame_size_large_params()` — frame size calculated correctly for large structs
   - `test_inout_small_return()` — verify InOut small becomes implicit return

2. Snapshot tests in `test/snapshots/webgl2/`:
   - `abi_inout_scalar.js` — InOut i32 becomes input param + extra return value
   - `abi_inout_large.js` — InOut 80-byte struct uses Frame copy-in/copy-out
   - `abi_no_scratch.js` — Assert generated WASM has zero scratch-pattern locals

3. Run full validation:
   ```bash
   cargo test --lib
   npm run build
   npm test
   ```

**Validation**:
- Run `npm test` — all 270+ tests pass
- Grep WASM output: verify no scratch-offset patterns
- Manual inspection: verify copy_in/copy_out sequences where expected
- **State**: ✅ GREEN

---

## Summary: Five Clean Phases

| Phase | Files | Goal | Status |
| :--- | :--- | :--- | :--- |
| 1 | Create `functions/` module | Registry infrastructure | Pure addition, zero behavior change |
| 2 | Enhance `function_abi.rs` | InOut semantics | Logic only, unused fields |
| 3 | Rewrite `expressions.rs`, `call_lowering.rs`, `control_flow.rs` | Eliminate scratch usage | Stack-first, keep allocation slot |
| 4 | Wire in `backend.rs`, `mod.rs` | Delete scratch block | Atomic integration |
| 5 | Add tests | Validation | Comprehensive coverage |

Each phase leaves the codebase **compilable, testable, and green**. No "partial refactor" states.

---

## Key Design Decisions

**1. Small (≤16 bytes) Return Values**
- Use WASM multi-value returns
- For InOut params: transform into input param + additional return value
- Avoids memory load/store overhead

**2. Large (>16 bytes) Return Values**
- Use Linear Stack (Return Slot Optimization pattern)
- Caller passes a pointer; callee writes result

**3. Frame Alignment**
- Always 16-byte alignment (global constant, not per-function)
- Simplifies logic, matches `vec4` alignment

**4. Entry Points**
- Special handling: fixed 6-pointer signature, global initialization
- Use same registry infrastructure as regular functions
- Separate `prep_entry_point()` path

**5. Call Semantics**
- Treat all unknown calls as potentially memory-touching
- Implement copy_in/copy_out conservatively
- Future optimization: opt-in `pure` annotation if needed

---

## Testing Strategy

- **Unit**: ABI computation, frame sizing, InOut transformation
- **Integration**: Large structs, arrays, mixed params, InOut semantics
- **Regression**: Full suite (265 tests unchanged)
- **Manual**: WAT inspection for copy sequences, frame allocation patterns

