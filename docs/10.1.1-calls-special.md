## Plan: Complete Function Call ABI Implementation with Semantic Detection and Memory Copying

This plan implements full support for GLSL function calls with `in`/`out`/`inout` parameters, handling large structs and arrays (>16 bytes) through frame-based memory copying.

---

## Step 1: Detect Parameter Semantics in FunctionABI

**File**: function_abi.rs

**Current state**: Inside `FunctionABI::compute()`, the parameter classification loop hardcodes `semantic: ParamSemantic::In` when creating `ParameterABI::Frame`. The `classify_type()` call receives `param_ty` directly without checking for pointer wrappers.

**Changes needed**:

1. **At the start of the parameter loop** in `FunctionABI::compute()`, before calling `classify_type()`, unwrap pointer types to detect semantics:
   ```rust
   let (semantic, actual_ty) = match &module.types[param_ty].inner {
       TypeInner::Pointer { base, space } if *space == AddressSpace::Function => 
           (ParamSemantic::InOut, *base),
       _ => (ParamSemantic::In, param_ty),
   };
   ```
   Then classify `actual_ty` instead of `param_ty`.

2. **In the Frame case** of the classification match, replace hardcoded copy_in and copy_out values with logic based on semantic: `In` sets copy_in=true/copy_out=false, `Out` sets copy_in=false/copy_out=true, `InOut` sets both to true.

3. **Add unit test** at end of file after the existing test functions. Name it `test_semantic_detection_inout_pointer`. Create a pointer-wrapped struct type and verify it becomes `ParamSemantic::InOut` with both copy flags true.

**Why this step is atomic**: Changes are internal to FunctionABI module. No callers use the new semantic detection or copy flags yet, so behavior is unchanged.

**Validation**: 
- Run `cargo test --lib function_abi` - expect 17 tests to pass (16 existing + 1 new)
- Run `npm test` - expect 265 tests to pass (no behavioral change)
- **State**: ✅ GREEN

---

## Step 2: Implement Complete Memory Copy Infrastructure

**Files**: call_lowering.rs, backend.rs, expressions.rs, EmitContext/TranslationContext definition

**Why these must be done together**: This forms an indivisible dependency chain:
- Changing `emit_frame_based_call()` signature breaks `emit_abi_call()` caller (won't compile)
- Changing `emit_abi_call()` signature breaks expressions.rs caller (won't compile)  
- expressions.rs needs ctx.scratch_locals_base which requires backend.rs changes
- Cannot split without creating non-compiling intermediate states

**Changes needed**:

### In call_lowering.rs:

1. **Add ScratchLocals struct** near the top after imports:
   ```rust
   struct ScratchLocals {
       old_sp: u32,
       aligned: u32,
       src_addr: u32,
       dest_addr: u32,
       temp_value: u32,
   }
   ```

2. **Add emit_memory_copy helper** at end of file after `handle_call_result()`. For sizes ≤64 bytes, emit unrolled i32.load/store pairs (size/4 iterations), plus i32.load8_u/store8 for remainder bytes. Use temp_local to hold values during copy.

3. **Update emit_frame_based_call signature** to accept `scratch_locals: &ScratchLocals` parameter.

4. **Implement copy_in logic** in the parameter marshalling loop after frame allocation: For each Frame parameter with copy_in=true, translate argument expression to get source pointer, calculate destination as aligned+offset, call emit_memory_copy. Push frame pointer as argument.

5. **Implement copy_out logic** after the call instruction, before frame free: For each Frame parameter with copy_out=true, calculate source as aligned+offset, re-translate argument for destination pointer, call emit_memory_copy to copy back.

6. **Update emit_abi_call signature** to accept `scratch_base: u32` parameter. In the uses_frame branch, construct ScratchLocals from scratch_base..scratch_base+4 and pass to emit_frame_based_call.

### In backend.rs:

7. **Allocate scratch locals** in `compile_function()` after processing LocalVariable arena: Add `func.local(5, ValType::I32)` and track the base index.

8. **Add scratch_locals_base field** to EmitContext or TranslationContext struct. Initialize with tracked base index after allocation.

### In expressions.rs:

9. **Update Call handling** to pass `ctx.scratch_locals_base` when calling `call_lowering::emit_abi_call()`.

**Implementation approach**: The complete infrastructure enables frame-based calls to copy large parameter data into/out of frame memory using pre-allocated scratch locals for address calculations.

**Why this step is atomic**: All signature changes, infrastructure additions, and wiring must happen together to maintain compilability. This is ONE logical feature: "memory copying for frame parameters."

**Validation**: 
- Run `cargo build` - must compile without errors
- Run `npm test` - expect 265 tests to pass (frame path now functional but rarely exercised in typical GLSL)
- **State**: ✅ GREEN

---

## Step 3: Test with Large Struct Parameters

**File**: [test/snapshots/webgl2/abi_large_struct.js](c:\Users\mihai\webgl2-2win\test\snapshots\webgl2\abi_large_struct.js)

**Current state**: Test exists with 80-byte struct parameter.

**Expected WAT patterns** after implementation:
- global.get/set on index 5 (FRAME_SP_GLOBAL) for allocation
- Multiple i32.load operations reading from PRIVATE_PTR + offset
- Corresponding i32.store operations writing to frame memory
- For 80 bytes: approximately 20 load/store pairs (one per 4-byte word)

**Update test assertions** in the test body: Count i32.store occurrences, verify at least 20 stores for the 80-byte copy. Verify frame allocation pattern with FRAME_SP_GLOBAL.

**Why this step is atomic**: Independent test addition, doesn't affect other tests.

**Validation**:
- Run `npm test -- test/snapshots/webgl2/abi_large_struct.js` - should pass
- Run `npm test` - all 266 tests should pass
- **State**: ✅ GREEN

---

## Step 4: Test with Arrays

**File**: [test/snapshots/webgl2/abi_arrays.js](c:\Users\mihai\webgl2-2win\test\snapshots\webgl2\abi_arrays.js)

**Scenarios to verify**:
- Small array float[4] (16 bytes) flattens to 4 f32 parameters
- Large array float[20] (80 bytes) becomes i32 pointer parameter with frame copy
Why this step is atomic**: Independent test addition.

**Validation**:
- Run `npm test -- test/snapshots/webgl2/abi_arrays.js` - should pass
- Run `npm test` - all 267 tests should pass  
- **State**: ✅ GREEN

---

## Step 5
**Run**: `npm test -- test/snapshots/webgl2/abi_arrays.js`

---

##Why this step is atomic**: Independent test addition.

**Validation**:
- Run `npm test -- test/snapshots/webgl2/abi_mixed_params.js` - should pass
- Run `npm test` - all 268 tests should pass
- **State**: ✅ GREEN

---

## Step 6**: Function with flattened scalars/vectors and one large struct parameter.

**Expected behavior**: Only the large parameter triggers frame allocation. Small parameters translate directly to stack values. Frame operations (global.get 5, memory copies) appear only once per call despite multiple parameters.

**Test assertion**: Count frame allocation operations, verify they occur exactly once (alloc + free pair). Verify function signature has mixed f32 and i32 parameters in correct order.
Why this step is atomic**: Independent test addition, documents future behavior.

**Note**: Will initially show conservative behavior (treats all pointers as InOut). Documents intended semantics for future optimization.

**Validation**:
- Test may initially fail if assertions are too strict - adjust to match conservative implementation
- Run `npm test` - should maintain green state
- **State**: ✅ GREEN (with possibly relaxed assertions)

---

## Step 7
## Step 12: Test with InOut Semantics (Future)

**File**: Create [test/snapshots/webgl2/abi_inout.js](c:\Users\mihai\webgl2-2win\test\snapshots\webgl2\abi_inout.js)

**Scenario**: Function with inout parameter modifying a large struct.

**Expected behavior**: Double the memory operations - copy_in before call, copy_out after call. For 80-byte struct: 20 loads/stores before call, 20 more after call, total 40 of each.
**Why this step is atomic**: Pure validation, no code changes.

**Validation**:
- Run `npm test` - expect all tests pass (265+ original + new ABI tests)
- Manually verify flattened path unchanged in WAT output samples
- **State**: ✅ GREEN

---

## Step 8
**Note**: Will initially show conservative behavior (treats all pointers as InOut). Documents intended semantics for future optimization.

**Why this step is atomic**: Documentation-only change, no code or test behavior affected.

**Validation**:
- Review documentation accuracy
- **State**: ✅ GREEN

---

## Step 9: Validate No Regressions

**Why this step is atomic**: Optional benchmark addition, doesn't affect test suite.

**Validation**:
- Benchmark runs successfully
- Results documented  
- Run `npm test` - all tests still pass
- **State**: ✅ GREEN

---

## Summary: Incremental Steps Guaranteeing Green State

This plan consists of **9 rigorous steps**, each leaving the project in a compilable, tested, green state:

1. **Step 1** (FunctionABI semantics): Internal module change, no callers affected
2. **Step 2** (Complete infrastructure): Atomic feature - all signature changes + implementation together
3. **Steps 3-6** (Individual tests): Each test is independent
4. **Step 7** (Regression validation): Pure validation checkpoint
5. **Step 8** (Documentation): Documentation update
6. **Step 9** (Performance): Optional benchmark

**Critical insight**: Step 2 cannot be split further without breaking compilation. It represents the minimal atomic unit for the memory copy feature. Any attempt to subdivide it would create non-compiling intermediate states.

**Why this is the smallest viable plan**: 
- Step 1 can be isolated (pure FunctionABI internal logic)
- Step 2 is indivisible (signature cascade requires all changes together)
- Steps 3-6 are independent test additions (already minimal)
- Steps 7-9 are validation/documentation (already minimal)

Attempting to create smaller steps would either:
- Break compilation between steps (violates green state requirement)
- Create fake "steps" that are really just partial work on Step 2 (not independently verifiable)

**Run full test suite**: `npm test`

**Expected results**:
- All 265 existing tests pass unchanged
- Flattened path (≤16 bytes) has identical behavior
- Only new frame-based tests exercise the copy logic
- No spurious frame allocations for small types

**Specific checks**:
- Functions with only small parameters don't allocate frames
- FRAME_SP_GLOBAL only touched when uses_frame=true in FunctionABI
- Function signatures unchanged for existing shader patterns

---

## Step 14: Update Documentation

**File**: [docs/10.1-calls.md](c:\Users\mihai\webgl2-2win\docs\10.1-calls.md)

**Add implementation status section** in the PR 5 entry:

Mark PR 5 as complete with checkmark. Document semantic detection via pointer wrapper analysis, memory copy implementation with unrolled strategy, and test coverage. List known limitations: conservative InOut treatment, 64-byte unroll threshold, no LocalVariable direct-pointer optimization yet.

**Include test command**: `npm test -- test/snapshots/webgl2/abi_*.js` with expected pass/fail breakdown.

---

## Step 15: Performance Validation

**Create benchmark** [test/benchmark_abi.js](c:\Users\mihai\webgl2-2win\test\benchmark_abi.js):

Compare flattened 16-byte struct calls versus frame-based 160-byte struct calls in a loop. Measure relative overhead - expect frame-based to be 2-3x slower due to memory operations. Document that this is acceptable for typical GLSL ES 3.0 usage patterns where large struct parameters are rare.

**Validation approach**: Run both call patterns 1000 times, record timing difference, verify overhead is reasonable and deterministic.

---

## Edge Cases and Error Handling

### 1. Recursive Calls with Frame Allocation
**Protection**: LIFO allocation ensures caller's frame remains valid during callee execution. Each call gets independent frame region. Test with abi_nested_calls.js verifies frame isolation.

### 2. Frame Stack Overflow
**Current behavior**: Silent overflow if exceeding 128KB frame region.

**Future enhancement**: Add overflow check in `emit_alloc_frame()` comparing new FRAME_SP against FRAME_END constant (0xA0000), trap with unreachable if exceeded.

### 3. Unaligned Struct Members
**Handled**: Naga type system includes GLSL padding rules in struct span field. Memory copy operates on full size including padding, maintaining alignment naturally.

### 4. Arrays of Structs
**Handled**: `classify_type()` computes total size using array size multiplied by struct span, including stride and padding. No special casing needed.

### 5. Out Parameter to Literal
**Validated**: Frontend rejects this. Defense: Naga only represents out/inout as Pointer types, and only writable locations produce pointers. Backend can assume arguments are valid.

---

## Testing Strategy Summary

### Unit Tests (Rust)
- function_abi.rs: 17 tests (16 existing + 1 semantic detection)
- Run: `cargo test --lib function_abi`

### Integration Tests (JavaScript)
- Six abi_*.js tests covering large structs, arrays, mixed params, matrices, edge cases, nested calls
- Run: `npm test -- test/snapshots/webgl2/abi_*.js`

### Regression Tests
- Full suite: `npm test` (265 existing tests must pass)

### Manual Validation
- Inspect WAT output for correct memory operation sequences
- Verify frame allocation patterns and FRAME_SP_GLOBAL usage
- Check parameter ordering in function signatures

---

## Completion Criteria

**Definition of Done**:
1. `FunctionABI::compute()` detects In/Out/InOut from TypeInner::Pointer wrapper
2. `emit_memory_copy()` helper correctly unrolls load/store sequences
3. copy_in implemented for In and InOut parameters in `emit_frame_based_call()`
4. copy_out implemented for Out and InOut parameters in `emit_frame_based_call()`
5. Scratch locals allocated in `compile_function()` and accessible via context
6. All frame-based ABI tests pass
7. Zero regressions on existing 265 tests
8. Documentation updated with implementation status in PR 5 section

**Success Metrics**:
- Test count: 270+ passing (265 existing + 5+ new)
- Coverage: All parameter size classifications tested
- Performance: Frame overhead within 3x of flattened calls
- Correctness: WAT output manually verified for sample cases

