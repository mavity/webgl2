# Typifying the Naga WASM Backend

The `naga_wasm_backend` is indeed treating most values as `F32` by default when loading from memory, and using bit-casts (`F32ReinterpretI32` / `I32ReinterpretF32`) to handle integers. This strategy, while uniform, is causing data corruption for integer values that correspond to NaN bit patterns (like `-1` or `0xFFFFFFFF`), because `F32Load` can canonicalize NaNs, altering the bits.

To systematically typify the backend, changes are required primarily in expressions.rs.

### Assessment of Required Changes

**1. expressions.rs**

*   **`Expression::Literal`**:
    *   Currently: `I32Const` followed by `F32ReinterpretI32` for integer literals.
    *   Change: Remove `F32ReinterpretI32`. Leave values as `I32` on the stack.

*   **`Expression::GlobalVariable`**:
    *   Currently: Unconditionally uses `F32Load`.
    *   Change: Check `ctx.module.global_variables[*handle].ty`. If it resolves to `Sint`, `Uint`, or `Bool`, use `I32Load`. Use `F32Load` only for `Float`.

*   **`Expression::FunctionArgument` (Entry Point case)**:
    *   Currently: Unconditionally uses `F32Load` to read attributes/uniforms from memory.
    *   Change: Check the argument type. Use `I32Load` for integer types and `F32Load` for float types.

*   **`Expression::Load`**:
    *   Currently: Unconditionally uses `F32Load`.
    *   Change: Check the type of the pointer being loaded. Use `I32Load` or `F32Load` accordingly.

*   **`Expression::AccessIndex`**:
    *   Currently: Unconditionally uses `F32Load` for pointer access.
    *   Change: Check the type of the element being accessed. Use `I32Load` or `F32Load`.

*   **`Expression::Binary`**:
    *   Currently: Inserts `I32ReinterpretF32` before integer ops and `F32ReinterpretI32` after integer ops.
    *   Change: Remove these reinterprets. The operands will already be `I32` (from `I32Load` or `I32Const`), and the result should remain `I32`.

*   **`Expression::Unary`**:
    *   Currently: Similar to Binary, uses reinterprets.
    *   Change: Remove reinterprets for integer operations.

*   **`Expression::As` (Type Conversion)**:
    *   Currently: Often relies on reinterprets or specific cast sequences.
    *   Change: Ensure conversions (e.g., `Sint` -> `Float`) use the correct WASM instructions (`F32ConvertI32S`) without assuming the input is `F32` bits.

**2. backend.rs**

*   The function signature generation using `naga_to_wasm_types` is already correct (`I32` for ints, `F32` for floats).
*   The current implementation of expressions.rs (forcing `F32`) likely produces invalid WASM for internal functions with integer arguments (mismatch between `LocalGet` returning `I32` and `I32ReinterpretF32` expecting `F32`). Fixing expressions.rs will resolve this latent issue.

**3. types.rs**

*   No changes needed. It already maps `Sint`/`Uint` to `ValType::I32` and `Float` to `ValType::F32`.

### Conclusion

The backend needs to be refactored to respect the types defined in types.rs throughout the expression translation process, rather than coercing everything to `F32`. This will fix the `vertexAttribI*` test failures by preserving the exact bit patterns of integer attributes.

# Appendix: Bug already indicated in current tests due to mistypification

The failing tests in gl-vertex-attrib-i-render.test.js are:
1. `constant attributes`: Fails. Uses `vertexAttribI4i` with negative values (`-1, 2, -3, 4`).
2. `vertexAttribIPointer u32`: Fails. Uses `vertexAttribI4i` (loc 0) with negative values.

The passing tests are:
1. `vertexAttribIPointer i32`: Passes. Uses `vertexAttribIPointer` with negative values (`-1, 2, -3, 4`).
2. `vertexAttribIPointer small types`: Passes.

The issue appears to be in expressions.rs. The backend unconditionally uses `F32Load` for loading global variables (which include vertex attributes), regardless of their type.

In expressions.rs:
```rust
        Expression::GlobalVariable(handle) => {
            // ...
                let ty = &ctx.module.global_variables[*handle].ty;
                let inner = &ctx.module.types[*ty].inner;
                match inner {
                    naga::TypeInner::Image { .. } | naga::TypeInner::Sampler { .. } => {
                        // ...
                    }
                    _ => {
                        ctx.wasm_func
                            .instruction(&Instruction::F32Load(wasm_encoder::MemArg {
                                offset: 0,
                                align: 2,
                                memory_index: 0,
                            }));
                    }
                }
```

When loading integer attributes that have negative values (e.g., `-1` which is `0xFFFFFFFF`), `F32Load` interprets the bits as a floating-point number. `0xFFFFFFFF` corresponds to a NaN (Not a Number). While `I32ReinterpretF32` is used later to convert it back to an integer for comparison, the use of `F32Load` is risky because it treats the data as a float, and some environments or operations might canonicalize NaNs (changing their bit pattern), causing the subsequent integer comparison to fail.

The `vertexAttribI4i` test fails because it relies on `default_value` stored in the VAO, which is copied to memory and then loaded via `F32Load`. The `vertexAttribIPointer` test (which also uses `-1`) passes, which is surprising, but it might be due to subtle differences in how the data is written to memory or how the test execution aligns, potentially avoiding NaN canonicalization in that specific path. However, the use of `F32Load` for integers is fundamentally incorrect in the WASM backend.

To fix this, expressions.rs should be updated to check the variable type and use `I32Load` (or `I64Load`) for integer types, ensuring bit preservation.