# 1.1.1 — WebGL2 prototype: Rust-owned Context, JS thin-forwarder

Status: Draft

This document records the design and step-by-step plan for the WebAssembly-backed WebGL2 prototype where the native (Rust) side owns runtime state (Context, textures, buffers, framebuffers), and JavaScript exposes a single, minimal public API surface via a class `WasmWebGL2RenderingContext` that *forwards* all calls to wasm. The goal is deterministic resource ownership, clear error semantics, and minimal JS logic.

## Goals

- `webGL2()` creates a Rust-owned Context and returns a JS class instance named `WasmWebGL2RenderingContext`.
- All runtime state lives in Rust/WASM. JS is a thin forwarder: no emulation of WebGL behavior in JS.
- Explicit lifecycle: caller must call `destroy()` on the JS object to free wasm resources. Failing to call it leaks wasm memory only.
- No FinalizationRegistry, no threads/atomics, no sentinel handle values. Keep strategies simple and explicit.

## Constraints and rules

- WASM is single-threaded in this project. Do NOT use Mutex or Atomics.
- Global registry in Rust will be a single-threaded container (OnceCell + RefCell<HashMap<u32, Context>> or similar). Store next-handle in the same RefCell. 0 is reserved as invalid handle.
- No sentinels: always allocate handles for resources (contexts, textures, buffers, framebuffers). Multiple independent Context instances must be supported concurrently.
- JS must never emulate higher-level WebGL behavior — it must forward to Rust and surface Rust-produced errors.
- Memory policy: prefer simplicity. Provide `wasm_alloc`/`wasm_free`; start without a scratch region. JS writes into wasm memory before calling wasm; WASM writes into caller-provided memory for readbacks. If Rust needs to retain data beyond the call, Rust must copy it into owned storage.
- Re: typed-array views: JS must create or recreate views immediately before each memory access. Explicit rules appear later.

## High-level architecture

- Rust (WASM): owns `Context` struct instances. A global registry maps `u32 handle` -> `Context`.
  - Exports: handle lifecycle, allocator, last-error reader, and per-context WebGL2-like functions.
  - Error model: all exported functions return `u32 errno` (0 == OK). For richer messaging, Rust exposes `wasm_last_error_ptr()`/`wasm_last_error_len()` to fetch an UTF-8 error string.

- JavaScript:
  - Factory: `await webGL2()` loads/instantiates WASM and returns `new WasmWebGL2RenderingContext(wasmExports, ctxHandle)`.
  - Class `WasmWebGL2RenderingContext` is the only public class: it implements the full WebGL2RenderingContext method surface by *forwarding* to corresponding wasm exports. If a wasm export returns non-zero errno, JS will call `wasm_last_error_ptr/len` and throw Error(message).
  - Explicit `destroy()` method must be called. After `destroy()` methods throw.

## Rust API (sketch)

Naming convention: `wasm_*` for module-level helpers and `wasm_ctx_*` for per-context operations.

- wasm_create_context() -> u32 (handle, 0 on failure)
- wasm_destroy_context(handle: u32) -> u32 (errno)
- wasm_alloc(size: u32) -> u32 (ptr, 0 on failure)
- wasm_free(ptr: u32) -> u32 (errno)
- wasm_last_error_ptr() -> u32
- wasm_last_error_len() -> u32

Per-context (examples):
- wasm_ctx_create_texture(ctx: u32) -> u32 (tex handle, 0 on failure)
- wasm_ctx_delete_texture(ctx: u32, tex: u32) -> u32 (errno)
- wasm_ctx_bind_texture(ctx: u32, target: u32, tex: u32) -> u32
- wasm_ctx_tex_image_2d(ctx: u32, target: u32, level: i32, internalFormat: i32, width: u32, height: u32, border: i32, format: i32, type_: i32, ptr: u32, len: u32) -> u32
- wasm_ctx_create_framebuffer(ctx: u32) -> u32
- wasm_ctx_framebuffer_texture2d(ctx: u32, target: u32, attachment: u32, textarget: u32, tex: u32, level: i32) -> u32
- wasm_ctx_read_pixels(ctx: u32, x: i32, y: i32, width: u32, height: u32, format: u32, type_: u32, dest_ptr: u32, dest_len: u32) -> u32

Notes:
- Creation functions return non-zero handles on success; return 0 and set last-error on failure.
- All other functions return u32 errno; JS throws on non-zero after fetching last-error.
- Implement full life-cycle semantics to match WebGL2 where practical (delete invalidates handle; operations on deleted handles produce the appropriate WebGL behavior or clear errors).

## JS class: `WasmWebGL2RenderingContext` (behavior & requirements)

- Constructor: internal only. Use `webGL2()` to create.
- Fields: `_exports`, `_handle`, `_destroyed`.
- Methods: implement the full WebGL2RenderingContext method names. Each method:
  1. Validates `!this._destroyed` else throw.
  2. Marshals JS arguments to numbers/ptrs/lengths.
  3. For data uploads: calls `exports.wasm_alloc(len)` -> ptr (fail -> throw), creates a fresh `Uint8Array(exports.memory.buffer)` view and calls `mem.set(src, ptr)`, then calls the wasm function passing ptr/len. After the call, it calls `exports.wasm_free(ptr)`.
  4. For readbacks: allocate `destPtr = exports.wasm_alloc(len)`; call wasm read function; after success create a fresh `Uint8Array(exports.memory.buffer, destPtr, len)` and copy out to a returned TypedArray; then free via `wasm_free`.
  5. On return code !== 0: read `wasm_last_error_ptr/len` and throw Error(message).
- `destroy()` calls `exports.wasm_destroy_context(handle)` and marks `_destroyed = true`.

Important JS memory access rules (explicit)

1. Whenever JS writes to wasm memory, it MUST create a fresh view immediately before the write: `const mem = new Uint8Array(exports.memory.buffer); mem.set(src, destPtr);`.
2. Call the wasm export that consumes those bytes immediately after the write.
3. After a wasm call that may have grown memory (e.g., `wasm_alloc`), JS MUST create fresh views before reading/writing again. Example:
   - `const ptr = exports.wasm_alloc(len); // may grow memory`
   - `const mem = new Uint8Array(exports.memory.buffer); mem.set(src, ptr);` // create view only after alloc
   - `const rc = exports.wasm_ctx_tex_image_2d(..., ptr, len);`
   - `// if reading mem after the call, recreate view`.

Rationale: typed-array views may be detached or relocated when wasm memory grows; creating views immediately before use ensures correct pointer/length and avoids stale references.

## Error semantics

- All exports set an internal `last_error` string on failure and return errno (u32).
- JS must call `wasm_last_error_ptr()` and `wasm_last_error_len()` to get the message on non-zero errno. The factory and class provide a helper `_checkErr(code)` which reads the message and throws.
- Recommended errno constants (documented in Rust/JS header):
  - 0: OK
  - 1: ERR_INVALID_HANDLE
  - 2: ERR_OOM
  - 3: ERR_INVALID_ARGS
  - 4: ERR_NOT_IMPLEMENTED
  - 5: ERR_GL
  - 6: ERR_INTERNAL

## Memory & copy policy (explicit rules)

- JS -> WASM (uploads): single copy path is preferred.
  - JS `wasm_alloc(len)` then create view and write into wasm memory then call wasm. This performs a single copy (JS -> wasm linear memory).
  - After the wasm call returns, JS should `wasm_free(ptr)` unless Rust takes ownership explicitly and documents that it will free later.
- WASM -> JS (readPixels etc): JS allocates dest buffer in wasm with `wasm_alloc(len)` and passes ptr; wasm writes into that buffer synchronously; after wasm returns JS creates a fresh view and copies data to a JS TypedArray and frees the wasm allocation.
- Rust retention rule: if Rust needs to keep a pointer to data beyond the call boundary, it must allocate and copy data into owned Rust storage. JS must not pass pointers with the expectation that Rust will hold them without an explicit copy.

## Resource lifecycle & WebGL2 semantics

- All WebGL2 objects (textures, buffers, framebuffers, shaders, programs, etc.) must be created with a handle and deleted explicitly via delete calls. Rust enforces semantics similar to browser WebGL2 where practical.
- Deleting a resource while it's bound: Rust will implement semantics to match WebGL2 (binding to 0 or behavior as spec requires) — at minimum, handle becomes invalid and subsequent operations return appropriate errors.
- Context destruction (`wasm_destroy_context`) releases all resources owned by that Context.

## Implementation plan (step-by-step)

Prioritized small steps to get a working prototype quickly and iteratively:

1. Core plumbing (Rust) — Minimal, required first (TODO #2)
   - Implement single-threaded global registry in Rust: `OnceCell<RefCell<HashMap<u32, Context>>>` + `RefCell<u32>` next-handle.
   - Implement `wasm_create_context()` and `wasm_destroy_context()`.
   - Implement `wasm_alloc()` and `wasm_free()` thin wrappers over Rust allocator (or a simple bump allocator if needed).
   - Implement `wasm_last_error_ptr()`/`wasm_last_error_len()` and internal last-error buffer.
   - Add errno constants and error plumbing.

2. Minimal per-context operations (Rust) — get textures and framebuffers working (TODO #3)
   - `wasm_ctx_create_texture`, `wasm_ctx_delete_texture`, `wasm_ctx_bind_texture`.
   - `wasm_ctx_tex_image_2d` accepting ptr/len and uploading pixel data synchronously.
   - `wasm_ctx_create_framebuffer`, `wasm_ctx_framebuffer_texture2d`, `wasm_ctx_read_pixels` writing into caller-provided wasm memory.
   - Ensure resource lifecycle semantics align with WebGL2.

3. JS class & factory (TODO #4)
   - Add `webGL2()` factory in `index.js` that instantiates wasm (or uses existing adapter) and calls `wasm_create_context()`.
   - Implement `WasmWebGL2RenderingContext` class that forwards method names to wasm. Implement `_checkErr` helper to throw on non-zero errno.
   - Implement upload and readback helpers that use `wasm_alloc`/`wasm_free` and follow the explicit typed-array view rules.

4. Smoke test + automation (TODO #6)
   - Create `test/smoke.js` that builds wasm, loads `webgl2.wasm`, calls `webGL2()` and runs the 1×1 texture round-trip asserting pixel color.
   - Add `package.json` script `test:smoke`.

5. Expand API surface & stubs (parallel; TODO #3 continued)
   - Add stubs for the remainder of the WebGL2 API in Rust that return `ERR_NOT_IMPLEMENTED` until implemented. JS forwards all calls; tests verify behavior paths.

6. Hardening and cleanup (TODO #7)
   - Replace remaining `static mut` usages with the single-threaded OnceCell + RefCell registry.
   - Add dev-mode diagnostics for leaks.

7. CI (TODO #8)
   - Add GitHub Actions workflow to run build and `npm run test:smoke` on PRs/push.

## Tests & verification

- Smoke test (1×1 pixel round-trip). Should be added to `test/smoke.js` and run locally.
- Unit tests (Rust) for registry, handle allocation, alloc/free, and last-error plumbing.
- Integration tests (optional) exercising error paths (invalid handle, invalid args, OOM).

## Risks & mitigations

- Implementing the whole WebGL2 API in Rust is large. Mitigate by exposing the full method surface early with `ERR_NOT_IMPLEMENTED` stubs and iteratively implementing server-side functions.
- Leaked wasm memory if JS callers forget to call `destroy()`. Mitigate by documentation, smoke tests, and optionally a development-only leak checker.
- Memory view subtle bugs. Mitigate by clear developer docs and code comments with explicit view rules (see the memory section above).

## Next actions & owner

- Action: implement step 1 (Core plumbing) in Rust and build wasm. Owner: (agent / team member implementing).
- After success: implement step 2 (textures/framebuffers) and step 3 (JS class) in short iterations with smoke tests after each milestone.

---

Notes: This file is a living plan. If requirements change (e.g., we want automatic RC-based cleanup or multiple-threaded wasm), update the design and re-evaluate locking/atomics and finalization strategies.
