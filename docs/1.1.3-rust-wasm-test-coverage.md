# 1.1.3 — Rust/WASM test coverage (V8 + DWARF symbolication)

Status: proposal / PoC

This document describes a practical, repeatable pipeline to collect source-accurate Rust line coverage for tests that run as WASM under V8 (Node). The approach captures V8 precise coverage (function / byte-range hits) during test execution and resolves WASM offsets back to Rust file:line using DWARF symbol information embedded in the .wasm. This is a pragmatic alternative to building/linking compiler-rt for wasm and gives high-fidelity coverage when you control the test build.

Goals / contract
- Inputs: crate compiled for `wasm32-unknown-unknown` (test build), the wasm-bindgen test bundle or Node-compatible JS entry, and V8 coverage JSON produced from the test run.
- Output: a symbolicated coverage mapping (JSON and optional lcov) mapping executed offsets to {file:line} hits suitable for HTML/lcov reporting.
- Success criteria: for representative unit tests, mapped coverage points include the correct Rust source file and line for most non-inlined code; the pipeline is automatable in CI.

High-level pipeline (recommended)
1. Build a test-targeted wasm with DWARF and stable codegen so offsets map predictably.
   - Example cmd.exe flags:
     set RUSTFLAGS=-C debuginfo=2 -C codegen-units=1 -C opt-level=0
     set CARGO_INCREMENTAL=0
     cargo test --target wasm32-unknown-unknown --no-run
   - Rationale: `debuginfo=2` embeds DWARF; `codegen-units=1` and `opt-level=0` reduce reordering and inlining so mapping is simpler for PoC/test builds.

2. Produce a Node-compatible test bundle (wasm-bindgen) that the Node runner can require.
   - Example:
     wasm-bindgen --target nodejs --out-dir pkg target\wasm32-unknown-unknown\debug\<crate>.wasm

3. Run the wasm tests under Node while recording V8 precise coverage.
   - Use the Node inspector Profiler (`Profiler.startPreciseCoverage` / `Profiler.takePreciseCoverage`) in a small wrapper which requires the test bundle and waits for test completion. This yields a coverage JSON with script entries and function/range hits.
   - A PoC runner is provided at `scripts/node_coverage_runner.js`.

4. Extract WASM offsets from the V8 coverage JSON.
   - The V8 JSON lists scripts and function ranges. For the WASM script(s) extract the covered ranges / start offsets. A helper `scripts/v8cov_extract_offsets.js` is provided to emit a compact offsets list.

5. Symbolicate offsets -> Rust file:line using DWARF (gimli/object/addr2line).
   - Load the exact `.wasm` file you ran (must contain or be paired with DWARF sections).
   - Use `object` to parse sections and `addr2line` / `gimli` to read the DWARF line program.
   - For each offset produce the best-matching file:line (the PoC CLI `tools/wasm_cov_mapper` implements a minimal mapping using `addr2line::Context`).

6. Aggregate hits into lcov/HTML if desired.
   - Collapse mapped points per-file/line and emit lcov or Istanbul-compatible output for existing reporters (genhtml, lcov, or Istanbul tools). This step is straightforward once file:line pairs are available.

Tooling (PoC included)
- `scripts/node_coverage_runner.js`: Node inspector wrapper to collect V8 precise coverage JSON.
- `scripts/v8cov_extract_offsets.js`: extracts wasm offsets from V8 coverage JSON.
- `tools/wasm_cov_mapper`: a small Rust CLI (uses `object`, `addr2line`) that maps offsets from the extracted JSON to Rust frames and emits `mapped-coverage.json`.
- `llvm-profdata` / `llvm-cov`: optional, alternative canonical route if you prefer LLVM instrumentation instead of V8+DWARF symbolication.

Key technical considerations & pitfalls
- Use the *exact* .wasm file that was executed when symbolizing — offsets are byte-level and must match the binary you feed to the symbolizer.
- DWARF base addressing: the PoC assumes offsets map directly to symbolizer addresses in many rustc/LLVM configurations; if your toolchain uses a different base, the mapper must compute function-start addresses from the WASM code section and add offsets accordingly. This is a straightforward extension and the PoC is written to be extended.
- Inlining and optimizations: test builds should disable aggressive inlining and LTO for best line-level fidelity. If you later enable opt-level>0, be prepared to handle inlined call-site DWARF entries.
- External DWARF bundles (.dwp): if your toolchain emits split DWARF, ensure the mapper has access to the consolidated DWARF (.dwp) or embed debug sections in the .wasm.

CI / cargo integration notes
- Option A (preferred for quick adoption): Add a CI job or npm script that runs the pipeline after `cargo test --no-run`. The Node runner and mapper can be invoked from a simple shell script and the generated `mapped-coverage.json` converted to lcov/html.
- Option B (deeper integration): Use a cargo runner wrapper (via `.cargo/config.toml`) to replace the default test runner with a wrapper that enables coverage capture automatically when `cargo test` is invoked. This requires ensuring the wrapper is accessible in CI build agents.

When to choose V8+DWARF vs llvm-cov
- V8+DWARF: faster to integrate, no need to build/ship compiler-rt for wasm, works well when you run tests under Node and can control the test build flags. Good balance of engineering effort vs fidelity for unit tests.
- llvm-cov: canonical, produces the same source-based coverage as native Rust workflows. Choose this if you want the canonical llvm-cov HTML reports and are OK building/linking the profiler runtime for wasm or adding a host shim to write .profraw files from wasm runs.

Next steps / PoC improvements (recommended)
1. Extend `wasm_cov_mapper` to compute WASM code-section function-start addresses and translate V8's functionIndex+offset to DWARF PCs robustly. This will make symbolication reliable across toolchains.
2. Add lcov output mode and genhtml automation to produce HTML coverage reports in CI.
3. Optionally wire this pipeline to a cargo wrapper so `cargo test` (or an alternate command) produces symbolicated coverage end-to-end.

If you want, I will implement step (1) now and run the end-to-end PoC on the repository's tests, producing a sample `mapped-coverage.json` and a small CI-ready script. Reply with `run` to proceed.
