# 1.1.4 — Rust/WASM Test Runner (Node-hosted, wasm-based orchestrator)

Status: design / MVP plan

This document specifies the design for a Rust/WASM test runner that runs Rust tests compiled to WASM (target: `wasm32-unknown-unknown`) under Node.js, captures coverage via V8, and symbolicates those offsets to Rust source locations via DWARF. The design follows the PoC in `docs/1.1.3-rust-wasm-test-coverage.md` and extends it into a robust runner orchestrated by a small Node wrapper and a Rust head runner compiled to WASM.

Goals / contract
- Inputs:
  - A Rust crate compiled with tests for the `wasm32-unknown-unknown` target and with debug DWARF enabled. The produced wasm will be referred to as <crate>.wasm.
- Outputs:
  - Optional `coverage/<crate>.lcov` and HTML outputs produced via `wasm_cov_mapper` or other tooling.
  - (optional) `coverage/<crate>/v8-coverage.json` — raw V8 JSON produced by the Profiler inspector while tests are executed.
  - Exit code semantics: 0 if tests pass and coverage is produced cleanly; non-zero on test failures, tool failures, or critical mapping errors.


Success criteria
- For representative test crates, mapped coverage includes correct file:line hits for non-inlined code.
- The runner is usable locally and in CI with a small set of commands and configuration.

High level architecture

Components:
- Node thin wrapper (JS server/CLI)
  - Start-up loader for the runner WASM
  - Minimal host functions the runner expects, possibly just one: `eval` with everything else Rust/WASM instigates through the eval needle eye.
  - Attach to the inspector endpoint with `inspector` or DevTools Protocol and start/stop coverage snapshots.
  - Stores raw coverage artifacts under `coverage/<crate>/` for later symbolication.

- Runner WASM (Rust: head process compiled to wasm)
  - Orchestrates test invocation and mapping workflow.
  - Calls host functions (likely just one eval function) to spawn the worker and to fetch results.
  - Contains orchestration logic for: capability checks, runtime configuration, spawning the worker, receiving coverage JSON, invoking symbolication, and writing final artifacts.
  - Embeds symbolication logic via `gimli`/`addr2line` compiled to WASM (future/optional; MVP uses a native helper).

- Worker (at runtime secondary Node process, but not a separate JS file)
  - Node process launched with inspector flags (e.g., `--inspect-brk`) by the Node wrapper at the instigation of WASM runner.
  - Loads the test binary via direct `WebAssembly.instantiate` (custom harness) and executes tests.
  - Runs deterministically: start a single run that executes all tests and exits with code representing test pass/fail.

- Symbolicator (embedded inside WASM)
  - `tools/wasm_cov_mapper` — native CLI used in the MVP
  - Symbolicator compiled to WASM and included within the runner for a self-contained toolchain.

Sequence of operations
1. Build the target crate for wasm test artifacts with DWARF and conservative optimization flags recommended for better mapping fidelity:
   - Example:
     - Linux/macOS:
       - `export RUSTFLAGS='-C debuginfo=2 -C codegen-units=1 -C opt-level=0'`
       - `export CARGO_INCREMENTAL=0`
       - `cargo test --target wasm32-unknown-unknown --no-run`
2. Build runner WASM (Rust) with debug info to allow introspection and possible symbolication locally:
   - `export RUSTFLAGS='-C debuginfo=2'`
   - `cargo build --manifest-path runner/Cargo.toml --target wasm32-unknown-unknown --release` (or debug for local dev).
3. Run the Node thin wrapper which runs the runner WASM, handing control to it. Runner asks Node to spawn an inspector-attached child to execute the target test crate.
   - Example: `node cli/runner.js coverage/<crate>.wasm --out coverage/<crate> --harness libtest`.
4. Worker runs under inspector; Node wrapper attaches and collects V8 coverage JSON using Profiler APIs, writes `v8-coverage.json`.
5. Runner invokes the symbolication sequence via statically linked `wasm_cov_mapper` → and optional `lcov`.
6. Runner writes final artifacts, prints summary, and returns the exit code.

## Core interfaces and data shapes

### WASM-Host ABI (minimal, fixed contract)

The runner WASM and Node wrapper communicate via a minimal two-function ABI:

**WASM Exports:**
- `run(argv_ptr: u32) -> i32`
  - Single entrypoint for control flow and events.
  - `argv_ptr` points to an a flat sequence of argument strings all zero-terminated, the end of list is two zero bytes in WASM linear memory (or command-line style arguments).
  - Returns an exit code (0 = success, non-zero = error or test failure).
  - Re-entrancy is allowed: `run` may invoke the host `eval` import which schedules async work in Node, and later re-enter `run` when that async work completes. On re-entrance, `argv_ptr` contains whatever Rust asked the JavaScript to pass back. JavaScript don't really need to pass anything via argv_ptr because it can store data directly back into WASM memory, given that Rust knows the addresses at the point it generates JavaScript. In that case `argv_ptr` can just be a token value that helps Rust identify the re-entrance context.
- `memory: WebAssembly.Memory` (exported, required)
  - The runner's linear memory, used for string passing and buffer management.

**Host Imports (from Node wrapper to runner):**
- `eval(js_ptr: u32, scratch_ptr: u32) -> void`
  - **Purpose:** evaluate arbitrary JavaScript and return a result.
  - **Parameters:**
    - `js_ptr`: pointer to a zero-terminated JavaScript string in WASM linear memory. Rust is responsible for writing this string.
    - `scratch_ptr`: pointer to a scratch buffer in WASM linear memory where the host will write the JavaScript evaluation result as a zero-terminated string.
  - **Contract:** the host evaluates the JS code, writes the result (as a zero-terminated string) into the scratch buffer, and returns. The runner is responsible for ensuring the scratch buffer is large enough; if the result would overflow, the host writes up to the available space, leaving a zero terminator at the end.
  - No allocator, no return value beyond void. No error codes; exceptions in eval cause the host to write an error message string to the scratch buffer and return normally. Rust generating the JavaScript can generate try/catch and deal with exceptions to any extent necessary for the use case.
  - Rust must manage scratch buffer lifecycle and sizing; typically allocate a fixed large buffer (e.g., 64 KB or suitable for expected result sizes) and reuse it across eval calls.

**Memory Model:**
- All ABI strings are zero-terminated.
- Pointers are 32-bit offsets into WASM linear memory.
- The runner is responsible for pre-allocating or managing scratch buffers; the host does not allocate on behalf of the runner.

### Re-entrancy Model

The runner better be re-entrant-safe:
- Each `run(...)` invocation is treated as an event or continuation handler.
- `run` may call `eval` to schedule async work (e.g., via JavaScript Promises) that later calls `run` again.
- Internally, the runner should maintain a task queue or state machine to handle continued execution across re-entries; avoid global mutable state that assumes a single call lifetime. Idea: explore `async`/`await` executor/scheduler handled via re-entrancy i.e. use `Rc<RefCell<...>>` or similar for non-reentrant-only state, or design the runner as a task executor where each `run` call processes one event from an internal queue.

## Libtest and alternatives

1) Full libtest on `wasm32-unknown-unknown` (preferred)
   - If `libtest` compiles and links on the target, this is the simplest path for developer ergonomics: tests are written the same, and harness semantics are unchanged.
   - The worker should call the standard `libtest` entrypoint and simply start running tests as if run by `cargo test`.
   - Caveat: `libtest` requires `std`/alloc features and some runtime support — depending on the toolchain this may be feasible only with `wasm-bindgen` or `wasm-pack` (if you are using `wasm-bindgen-test`). If unsupported we fallback to `libtest-compat`.

2) `libtest-compat` shim (fallback)
   - Provide a small crate or module that mirrors `libtest` test registration and execution (e.g., `libtest-mimic` or a custom simple harness). Expose a well-defined entrypoint `__run_tests()` which the worker can invoke after instantiating the test wasm.
   - Ergonomics: minimal change for test authors — the crate exports `#[test]`-like macros that register tests with the shim.
   - This approach guarantees deterministic test execution and is simpler to control for coverage collection.

### Modes of test discovery & invocation

- For `libtest`: the test harness entrypoint is present in the compiled wasm. Worker simply instantiates the wasm and runs the entry function (e.g., reusing `wasm-bindgen` glue).
- For `libtest-compat`: the test harness will export a `__run_tests` function and optionally a `__discover_tests` list. The worker will call `__run_tests` and wait for an exit code.

## Worker behavior and determinism

- Worker lifecycle:
  - Launch -> initialize runtime -> instantiate target wasm -> call (harness-specific) `run_all_tests() -> 0/1`.
  - On run completion, normal exit to Node with the test result as the exit code (0 = pass, non-zero = fail).
  - Worker must be single-run (no discovery or tools that may spawn additional invocations).

- The runner must enforce this lifecycle and ensure coverage capture includes the full run lifecycle from test start to test end.

## Symbolication and coverage mapping

- Symbolication tools are inspired by `tools/wasm_cov_mapper` which resolves offsets to file:line using embedded DWARF via `addr2line/gimli`.
  - The actual tool statically linked in WASM must be invoked with the exact wasm that was executed.
  - Optionally, compute base address translation depending on the wasm loader and V8 behavior (rare but necessary for some toolchains).

- Internal (future) — the runner embeds the symbolication logic (a `gimli`-powered mapping) compiled into the runner WASM; the runner maps offsets in-process and emits results.

## Node & V8 compatibility checks, capability detection, and error modes

- The Node wrapper MUST check the environment and Node version and ensure the DevTools Profiler can capture wasm details. If the engine offers partial support, the wrapper warns and proceeds. If no support is available, wrapper fails and produces error with version details and other info.

## Edge cases and mitigations

- DWARF split/paths: if the toolchain emits split DWARF (`.dwp`) or separate debug artifacts, ensure statically linked `wasm_cov_mapper` has access to consolidated DWARF. Offer a CLI flag `--dwp` path or `--dwarf-embed` to specify embedding.
- Optimization and inlining: by default, require `opt-level=0` and `codegen-units=1` for test builds; document how to handle opt-level > 0 if desired (expect more complex mapping due to inlining and DWARF call-site entries).
- WASM code base addresses: V8 may map wasm to module-specific bases. The mapper should be able to compute a translation from V8 `functionIndex + offset` to a DWARF PC using code section start addresses.
- Failing coverage gaps: For missing offsets, preserve the raw offsets and write them to artifacts so future symbolication runs or custom steps can process them.

## Security model

- Runner intentionally delegates OS-level process spawning to Node and does not execute arbitrary native code. During CI runs, ensure that only trusted test artifacts are executed.
- The worker process logs are collected and stored under `coverage/<crate>/` to help debug malicious or misbehaving tests.

## Test harness & example jobs

- Create `examples/` with a minimal Rust crate containing a couple of tests and a line that is intentionally uncovered to verify mapping.
- Implement node.js package.json script that builds the example with the recommended Rust flags and runs the runner with parameters for visible outputs.

## Tooling & Implementation plan (MVP)

Priority tasks:
1. 2. 3...

## Implementation notes and code-level details

- `libtest-compat` proposal:
  - Provide macros `#[wasm_test]` that registers a test in `TESTS: Vec<fn()>`.
  - Provide `__run_tests()` which iterates `TESTS` and exits with code 0 or >0 on failure.
  - Make sure tests can run asynchronously (return `Future`) or provide a `#[wasm_test(async)]` option.

- Example worker invocation (Node):
  - `node worker.js --mode libtest --target-pkg=coverage/<crate>/pkg` (for wasm-bindgen) or `node worker.js --target-wasm coverage/<crate>.wasm --mode libtest-compat`.

- Node inspector snippet (JS):
  - Use `inspector.Session(); session.connect(); session.post('Profiler.startPreciseCoverage', {})` before test start; `session.post('Profiler.takePreciseCoverage', {}, (err,res)=>{...})` after test completion.

## Metrics and validation criteria

...

## Next steps

...

## References
- `docs/1.1.3-rust-wasm-test-coverage.md` — PoC and symbolication tooling described.
- `scripts/node_coverage_runner.js` — initial inspector wrapper. (Proof-of-concept.)
- `scripts/v8cov_extract_offsets.js` — offset extractor.
- `tools/wasm_cov_mapper` — DWARF symbolication tool.

