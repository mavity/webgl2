# Decompiling WASM to GLSL

## Plan: Add `getShaderGLSL` via Rust-based Decompiler

This is a plan to implement a new module to decompile WASM bytecode back into GLSL-like C code, mirroring the existing `getShaderWat` functionality but using a custom "WASM-to-GLSL" decompiler instead of `wasmprinter`.

### Steps
1.  Create `src/wasm2glsl.rs` (new module) implementing a simple structured decompiler using `wasmparser`.
    *   It will parse the WASM binary, tracking locals and the expression stack.
    *   It will map WASM instructions (e.g., `f32.add`) to GLSL strings (e.g., `a + b`).
    *   It will handle structured control flow (`block`, `loop`, `if`) by tracking indentation depth.
2.  Register the new module in lib.rs and expose a new C-exported function `wasm_ctx_get_program_glsl_ref`.
3.  Update shaders.rs:
    *   Add `GLSL_STRING_STORAGE` (thread-local).
    *   Implement `ctx_get_program_glsl_ref` which calls `crate::wasm2glsl::convert`.
4.  Update webgl2_context.js to export `getShaderGLSL`, mirroring `getShaderWat`.

### Further Considerations
1.  **Complexity**: Reconstructing perfect GLSL from WASM is hard (Relooper problem). Since our WASM comes from Naga (which is structured), I will assume the input is well-structured and maps directly to GLSL blocks.
2.  **Types**: WASM is untyped (bits), GLSL is strict. I will infer types based on operations (e.g., `f32.add` → `float`, `i32.add` → `int`).
3.  **Wasmdec**: I will use `wasmdec`'s string templates (from Conversion.cc) as a reference for the mapping logic, but reimplement the traversal in Rust using `wasmparser`.

