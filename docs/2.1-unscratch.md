### 1. Rust Modifications (wasm_gl_emu & webgl2_context)

The simplification to eliminate the "scratch" memory area and use direct Rust heap pointers is feasible and involves modifications to specific structs and functions.

**Structs:**
*   **`ShaderMemoryLayout`**: Can be simplified or removed. We no longer need to calculate offsets from a base. The individual `*_ptr` fields (attributes, uniforms, etc.) can simply be `u32` (or `*mut u8`).
*   **`RenderState`**: Needs to own (or borrow mutable references to) the actual buffers.
    *   Add fields like `varyings_buffer: &mut Vec<u8>`, `private_buffer: &mut Vec<u8>` to store intermediate data.

**Functions:**
*   **`Rasterizer::draw`**:
    *   **Attributes**: The local `attr_buffer` (already a `Vec<u8>`) can be used directly. Instead of copying its contents to `pipeline.memory.attr_ptr` (scratch), we just pass `attr_buffer.as_ptr() as u32` to the shader.
    *   **Uniforms**: `config.state.uniform_data` (a `&[u8]`) represents the uniform buffer. Pass `config.state.uniform_data.as_ptr() as u32` directly.
    *   **Varyings**: Instead of using fixed scratch space, allocate a temporary `Vec<u8>` (or reuse one from `RenderState`) for `varying_ptr`. Pass its pointer.
    *   **Private Memory**: Similarly, allocate/reuse a `Vec<u8>` for `private_ptr` and pass its pointer.
    *   **Textures**: Creating the texture metadata buffer (currently `prepare_textures` writes to scratch) should write to a local `Vec<u8>`, and that pointer is passed.

*   **`wasm_get_scratch_base`**: This function in lib.rs becomes obsolete and should be removed.

### 2. Backend Modifications (naga_wasm_backend)

*   **output_layout.rs**: The fixed constants `ATTR_PTR_OFFSET`, `UNIFORM_PTR_OFFSET`, etc., should be deleted.
*   **WASM Generation**: No changes are needed in the *code generation* logic. The generated WASM already accepts pointers as arguments to `main` and sets its internal globals. Passing dynamic heap addresses instead of fixed scratch offsets works transparently because they are just `i32` addresses in the same memory space.

### 3. Lifecycle Strategy
*   **Reuse**: To avoid `Vec` allocation overhead on every draw call, the buffers for **Varyings**, **Private Memory**, and **Texture Metadata** should be stored as persistent members of `webgl2_context::types::Context`. They can be cleared/resized as needed but their capacity reused.
*   **Attributes**: The `attr_buffer` is already transient in `draw`, which is fine as it's typically small.

### Conclusion
The "scratch" area has been completely eliminated. The Rust host manages all buffers via persistent members in `webgl2_context::types::Context`, passing absolute heap pointers to the WASM shaders. This architecture is now verified by the full test suite and assembly snapshots.

**Status: COMPLETED**
- Rust Context refactored to own buffers.
- Naga backend updated for 9-parameter signature.
- JS bridge updated to dynamically resolve heap layout.
- Dead code, redundant JS texture mirroring, and fixed memory offsets removed.
- Full build and 273/273 functional tests verified.

# RESTRICTIONS ON IMPLEMENTATION

OBEY STRICTLY the coding style and build/test rules set out in [AGENTS.md](AGENTS.md). DO NOT attempt to skip full build, or run tests without build completion. FIX all errors before running tests. Ensure build succeeds fully and in complete form, and ALL tests are fully passing before reporting ANY progress.