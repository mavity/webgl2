# Error handling consistency

Based on the review of the codebase, build warnings, and existing TODOs, here is a detailed proposal for a unified error handling facility.

### 1. Executive Summary

The project currently suffers from fragmented error handling. The WebGL2 implementation uses a thread-local string buffer (`LAST_ERROR`) defined in types.rs, while the WebGPU implementation returns simple integer error codes (e.g., `WEBGPU_ERROR_INVALID_HANDLE`) and discards detailed error messages from the underlying `wgpu` library. This leads to a loss of critical debugging information and inconsistent behavior for API consumers.

This proposal outlines a unified `src/error.rs` module that serves as the single source of truth for error reporting across WebGL, WebGPU, and other subsystems. This will allow detailed error messages to be captured in Rust and surfaced to JavaScript in a consistent manner, respecting the different error models of WebGL (sticky global error) and WebGPU (error scope stack).

### 2. Current State Analysis

*   **WebGL2:** Uses a `thread_local!` static `LAST_ERROR` in types.rs. Errors are set via `set_last_error` and exposed to JS via `last_error_ptr` / `last_error_len`.
*   **WebGPU:** Defines integer error codes in mod.rs. The implementation in `src/webgpu/*.rs` catches `wgpu` errors but often discards the error message, returning a generic error code instead.
*   **Build Warnings:** Numerous `unused variable: e` warnings in webgpu confirm that `wgpu` error details are being ignored.
*   **TODOs:** Multiple comments like `// TODO: handle properly, propagate error` exist in texture.rs, shader.rs, and command.rs.

### 3. Proposed Architecture

#### 3.1 New Module: `src/error.rs`

We will create a new module `src/error.rs` to centralize error storage. This module will replace the ad-hoc `LAST_ERROR` in WebGL and provide the missing infrastructure for WebGPU.

It introduces a dual-mode error storage system: a "Sticky" slot for WebGL and a "Scope Stack" for WebGPU.

```rust
use std::cell::RefCell;
use std::ffi::CString;
use std::os::raw::c_char;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ErrorSource {
    WebGL,
    WebGPU(WebGPUErrorFilter),
    System,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum WebGPUErrorFilter {
    Validation,
    OutOfMemory,
    Internal,
}

#[derive(Debug, Clone)]
pub struct WasmError {
    pub code: u32,
    pub message: String,
    pub source: ErrorSource,
}

struct ErrorState {
    /// WebGL: Single sticky error slot.
    webgl_last_error: Option<WasmError>,
    
    /// WebGPU: Stack of error scopes. 
    /// Each scope is (WebGPUErrorFilter, Option<WasmError>) capturing the filter and the *first* error in that scope.
    /// If the stack is empty, errors are "uncaptured" (logged/evented).
    webgpu_scope_stack: Vec<(WebGPUErrorFilter, Option<WasmError>)>,
    
    /// FFI: Persistent buffer for the last retrieved error message to ensure safety.
    ffi_buffer: Option<CString>,
}

thread_local! {
    static STATE: RefCell<ErrorState> = RefCell::new(ErrorState {
        webgl_last_error: None,
        webgpu_scope_stack: Vec::new(),
        ffi_buffer: None,
    });
}
```

#### 3.2 Unified "Push" Mechanism

The `set_error` function will intelligently route the error based on the `ErrorSource`. It implements the "Bubbling" logic for WebGPU: if an error doesn't match the current scope's filter, it travels down the stack until it finds a match or runs out of scopes.

```rust
pub fn set_error(source: ErrorSource, code: u32, msg: impl ToString) {
    STATE.with(|s| {
        let mut state = s.borrow_mut();
        let error = WasmError {
            code,
            message: msg.to_string(),
            source,
        };

        match source {
            ErrorSource::WebGL => {
                // WebGL: Overwrite sticky error
                state.webgl_last_error = Some(error);
            }
            ErrorSource::WebGPU(error_filter) => {
                // WebGPU: Bubble down the stack
                let mut captured = false;
                
                // Iterate from top (most recent) to bottom
                for (scope_filter, scope_error) in state.webgpu_scope_stack.iter_mut().rev() {
                    if *scope_filter == error_filter {
                        // Found a matching scope
                        if scope_error.is_none() {
                            *scope_error = Some(error.clone());
                        }
                        captured = true;
                        break; // Stop bubbling once captured
                    }
                }

                if !captured {
                    // Uncaptured error: Log immediately or trigger global handler
                    crate::js_log(0, &format!("Uncaptured WebGPU Error: {}", error.message));
                }
            }
            _ => {
                // System/Other: Log immediately
                crate::js_log(0, &format!("System Error: {}", error.message));
            }
        }
    });
}
```

#### 3.3 WebGPU Scope Management

We need to expose functions to manage the stack, corresponding to `pushErrorScope` and `popErrorScope`.

```rust
pub fn webgpu_push_error_scope(filter: WebGPUErrorFilter) {
    STATE.with(|s| {
        s.borrow_mut().webgpu_scope_stack.push((filter, None));
    });
}

pub fn webgpu_pop_error_scope() -> Option<WasmError> {
    STATE.with(|s| {
        s.borrow_mut().webgpu_scope_stack.pop().and_then(|(_filter, err)| err)
    })
}
```

#### 3.4 The "Poisoned Handle" Strategy (Avenue 1)

For WebGPU, when an error occurs during object creation (e.g., `createBuffer`), we must not simply return `0` (null). We must return a valid handle to a "Zombie" object.

**Plan for `src/webgpu/registry.rs` (or similar):**
1.  Define a `Poisoned` state for resources.
2.  When `wgpu` returns an error:
    *   Call `error::set_error(...)` to capture the details.
    *   Allocate a new handle ID.
    *   Store a "Poisoned" resource entry in the registry for that ID.
    *   Return the ID.
3.  Downstream functions (e.g., `bufferSubData`) check if the handle is Poisoned.
    *   If Poisoned: `set_error(Validation, "Invalid Handle: Buffer is poisoned")` and return.

#### 3.5 Safe FFI Exports

Implementation of the safe string export using the persistent buffer.

```rust
#[no_mangle]
pub extern "C" fn wasm_get_last_error_msg_ptr() -> *const c_char {
    STATE.with(|s| {
        let mut state = s.borrow_mut();
        
        // Prioritize WebGL error for this specific API, or expose separate accessors
        // For now, let's assume this pulls the WebGL sticky error
        if let Some(err) = &state.webgl_last_error {
            let c_str = CString::new(err.message.clone()).unwrap_or_default();
            let ptr = c_str.as_ptr();
            state.ffi_buffer = Some(c_str); // Keep alive
            ptr
        } else {
            std::ptr::null()
        }
    })
}
```

### 4. Implementation Plan

1.  **Create `src/error.rs`**: Implement the `ErrorState` struct and `thread_local` storage.
2.  **Refactor WebGL**: Switch `webgl2_context` to use `state.webgl_last_error`.
3.  **Refactor WebGPU**:
    *   Update `mod.rs` to import the error module.
    *   Implement `pushErrorScope` / `popErrorScope` bindings.
    *   Systematically go through `src/webgpu/*.rs` and replace ignored errors with `set_error` calls.
4.  **Implement Poisoning**: Update WebGPU resource creation to return poisoned handles on failure.
5.  **Expose to JS**: Add the export functions in `lib.rs`.
6.  **Update JS Bindings**: Update `webgl2_context.js` and `webgpu_context.js` to call these new exports.

### 5. Benefits

*   **Consistency:** Both APIs behave identically regarding error reporting.
*   **Debuggability:** "Invalid Handle" becomes "Invalid Handle: Buffer ID 5 destroyed" or "Validation Error: Buffer size too small".
*   **Maintainability:** Centralized logic reduces code duplication.
*   **Compliance:** Resolves the pending TODOs and build warnings, and correctly implements WebGPU error scoping.

### 6. Unit Testing Strategy

To ensure the new error handling system is robust, we will implement a multi-layered testing strategy.

#### 6.1 Rust Unit Tests (`src/error.rs`)

These tests will verify the correctness of the `ErrorState` logic in isolation, ensuring the "Sticky" vs. "Stack" behavior works as designed.

*   **Test Case: WebGL Sticky Behavior**
    *   **Action:** Call `set_error(WebGL, ...)` with "Error A".
    *   **Assertion:** `get_last_error_message()` returns "Error A".
    *   **Action:** Call `set_error(WebGL, ...)` with "Error B".
    *   **Assertion:** `get_last_error_message()` returns "Error B" (overwrite).

*   **Test Case: WebGPU Scope Stack (Basic)**
    *   **Action:** `webgpu_push_error_scope(Validation)`.
    *   **Action:** `set_error(WebGPU, Validation, "Fail")`.
    *   **Action:** `webgpu_pop_error_scope()`.
    *   **Assertion:** Returns `Some(WasmError)` with message "Fail".

*   **Test Case: WebGPU Scope Stack (Empty)**
    *   **Action:** `webgpu_push_error_scope(Validation)`.
    *   **Action:** (Do nothing).
    *   **Action:** `webgpu_pop_error_scope()`.
    *   **Assertion:** Returns `None`.

*   **Test Case: WebGPU Nested Scopes**
    *   **Action:** `push_scope(Scope A)`.
    *   **Action:** `push_scope(Scope B)`.
    *   **Action:** `set_error(...)`.
    *   **Action:** `pop_scope()`.
    *   **Assertion:** Returns the error (captured by inner Scope B).
    *   **Action:** `pop_scope()`.
    *   **Assertion:** Returns `None` (Scope A is empty because B caught it).

*   **Test Case: WebGPU Filter Logic (Bubbling)**
    *   **Action:** `push_scope(OutOfMemory)`.
    *   **Action:** `push_scope(Validation)`.
    *   **Action:** `set_error(WebGPU, OutOfMemory, "OOM")`.
    *   **Assertion:** Error is **not** captured by the inner Validation scope.
    *   **Assertion:** Error **is** captured by the outer OutOfMemory scope.
    *   **Action:** `pop_scope()` (Validation).
    *   **Assertion:** Returns `None`.
    *   **Action:** `pop_scope()` (OOM).
    *   **Assertion:** Returns `Some("OOM")`.

#### 6.2 JavaScript End-to-End Tests (`test/webgpu_errors.test.js`)

These tests verify the FFI boundary and the developer experience.

*   **Test Case: `pushErrorScope` / `popErrorScope` Binding**
    ```javascript
    device.pushErrorScope('validation');
    device.createBuffer({ size: 0, usage: 0 }); // Invalid
    const error = await device.popErrorScope();
    assert(error instanceof GPUValidationError);
    ```

*   **Test Case: Uncaptured Error Event**
    ```javascript
    let caught = null;
    device.onuncapturederror = (e) => { caught = e; };
    device.createBuffer({ size: 0, usage: 0 }); // No scope
    assert(caught.error instanceof GPUValidationError);
    ```

*   **Test Case: Poisoned Object Usage**
    ```javascript
    device.pushErrorScope('validation');
    const badBuf = device.createBuffer({ size: -1, usage: 0 }); // Should fail but return object
    device.popErrorScope(); // Clear the creation error

    device.pushErrorScope('validation');
    queue.writeBuffer(badBuf, 0, data); // Use poisoned object
    const error = await device.popErrorScope();
    assert(badBuf !== null);
    assert(error instanceof GPUValidationError);
    ```
